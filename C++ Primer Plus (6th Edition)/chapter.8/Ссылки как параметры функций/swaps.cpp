/*
Разумеется, язык С позволяет обойти ограничения, накладываемые передачей аргументов по значению, за счет применения указателей. 
Давайте сравним, как используются ссылки и указатели при решении простой задачи: обмен значениями двух переменных. 
Функция обмена должна иметь возможность изменять значения переменных в вызывающей программе. 
Это означает, что обычный подход, связанный с передачей переменных по значению, здесь не подойдет, поскольку функция выполнит обмен содержимым лишь копий исходных переменных, но не их самих. 
Однако если передавать ссылки, функция получит возможность работать с исходными данными. Вместо этого для получения доступа к исходным данным можно передавать указатели. 
В листинге 8.4 демонстрируются все три метода, включая и тот, который не дает желаемого результата, так что вы можете легко сравнить их. 
Листинг 8.4. swaps.срр */
// swaps.срр — обмен значениями с помощью ссылок и указателей 
#include <iostream>
void swapr(int & a, int & b); // a, b - псевдонимы для int 
void swapp(int * p, int * q); // p, q - адреса int 
void swapv(int a, int b); // a, b - новые переменные 
int main(void)
{
    using namespace std;
    int wallet1 = 300;
    int wallet2 = 350;
    cout << "wallet1 = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    // Использование ссылок для обмена содержимого 
    cout << "Using references to swap contents:\n";
    swapr(wallet1, wallet2); // передача переменных 
    cout << "wallet1 = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    // Использование указателей для обмена содержимого 
    cout << "Using pointers to swap contents again:\n";
    swapp(&wallet1, &wallet2); // передача адресов переменных 
    cout << "wallet1 = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;

    // Попытка использования передачи по значению 
    cout << "Trying to use passing by value:\n";
    swapv(wallet1, wallet2); // передача значений переменных 
    cout << "wallet1 = $" << wallet1;
    cout << " wallet2 = $" << wallet2 << endl;
    return 0;
}

void swapr(int & a, int & b) // использование ссылок 
{
    int temp;
    temp = a;   // использование a, b для получения значений переменных 
    a = b;
    b = temp;
}

void swapp(int * p, int * q) // использование указателей 
{
    int temp;
    temp = *p;  // использование *р, *q для получения значений переменных 
    *p = *q;
    *q = temp;
}

void swapv(int a, int b) // попытка использования значений 
{
    int temp;
    temp = a; // использование a, b для получения значений переменных 
    a = b;
    b = temp;
}
/*
Ниже показан вывод программы из листинга 8.4: 
walletl = $300 wallet2 = $350 <- исходные значения 
Using references to swap contents: 
walletl = $350 wallet2 = $300 <- обмен значениями выполнен 
Using pointers to swap contents again: 
walletl = $300 wallet2 = $350 <- обмен значениями снова выполнен 
Trying to use passing by value: 
walletl = $300 wallet2 = $350 <- обмен значениями не удался 

Замечания по программе 
Прежде всего, обратите внимание на то, как вызывается каждая функция в листинге 8.4: 
swapr(walletl, wallet2); // передача переменных 
swapp(Swalletl, &wallet2); // передача адресов переменных 
swapv(walletl, wallet2); // передача значений переменных 
Передача по ссылке (swapr (walletl, wallet2)) и передача по значению (swapv (walletl, wallet2)) выглядят идентично. 
Единственный способ определить, что функция swapr() передает аргументы по ссылке — обратиться к прототипу или определению функции. 
В то же время, наличие операции взятия адреса (&) явно говорит о том, что функции передается адрес значения (swapp(&walletl, &wallet2)). 
(Вспомните, что объявление типа int *р означает, что р — это указатель на int, поэтому аргумент, соответствующий р, должен быть адресом, таким как & walletl.) 
Далее сравним программный код функций swapr() (передача по ссылке) и swapv()(передача по значению). 
Единственное видимое различие между ними связано с объявлением параметров: 
void swapr(int & a, int & b) 
void swapv(int a, int b) 
Внутреннее различие между ними, естественно, состоит в том, что в функции swapr() переменные а и b служат псевдонимами имен walletl и wallet2, так что  
обмен значениями между а и b вызывает обмен значениями между переменными walletl и wallet2. 
В то же время в функции swapv() переменные а и b — это новые переменные, которые копируют значения переменных walletl и wallet2. 
В этом случае обмен значениями между а и b никак не влияет на переменные walletl Hwallet2. 
И, наконец, сравним функцию swapr () (передача ссылки) и swapp () (передача указателя). 
Первое различие кроется в объявлении параметров: 
void swapr(int & a, int & b) 
void swapp (int * p, int * q) 
Второе различие состоит в том, что вариант с указателем требует применения операции разыменования (*) во всех случаях, когда функция использует переменные р и q. 
Как уже упоминалось ранее, ссылочную переменную необходимо инициализировать при ее определении. 
Вызов функции инициализирует свои параметры значениями аргументов, передаваемых в вызове. 
Это значит, что следующий вызов функции инициализирует формальный параметр а значением wallet 1, а формальный параметр b — значением wallet2: 
swapr(walletl, wallet2); 
*/