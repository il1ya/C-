/* Современные компиляторы C++ реализуют одно из новейших добавлений к языку: шаблоны функций. Шаблон функции — это обобщенное описание функции; т.е. он 
определяет функцию в терминах обобщенного типа, вместо которого может быть подставлен определенный тип данных, такой как int или double. 
Передавая шаблону тип в качестве параметра, можно заставить компилятор сгенерировать функцию для этого конкретного типа. 
Поскольку шаблоны позволяют программировать в терминах обобщенного, а не специфического типа, этот процесс иногда называют обобщенным программированием. 
Поскольку типы представлены параметрами, средство шаблонов иногда называют параметризироѳанными типами. Давайте посмотрим, чем это средство полезно, и как оно работает. 
Перед тем, как в стандарте С++98 было добавлено новое ключевое слово typename, в рассматриваемом контексте использовалось ключевое слово class. 
Это значит, что определение шаблона можно записать в следующей форме: 
template <class AnyType> 
void Swap(АпуТуре &а, АпуТуре &Ь) 
{ 
    АпуТуре temp; 
    temp = а; 
    а = b; 
    b = temp; 
} 
Ключевое слово typename делает более очевидным тот факт, что параметр АпуТуре представляет тип; однако к тому времени были созданы большие библиотеки кода, в 
которых применялось старое ключевое слово class. В приведенном контексте стандарт C++ трактует оба эти ключевых слова как идентичные. 
В этой книге используются обе формы. 
Совет 
Шаблоны должны использоваться в тех случаях, когда необходимы функции, применяющие один и тот же алгоритм к различным типам данных. 
Если перед вами не стоит задача обеспечения обратной совместимости и не затрудняет набор более длинного слова, можете  
использовать при объявлении параметров типа ключевое слово typename, а не class. 
Чтобы сообщить компилятору о том, что нужна определенная форма функции обмена значениями, в программе достаточно вызвать функцию Swap(). 
Компилятор проанализирует типы передаваемых аргументов, а затем сгенерирует соответствующую функцию. 
В листинге 8.11 показано, как это делается. Формат программы выбран по образцу для обычных функций — прототип шаблона функции располагается в верхней 
части файла, а определение шаблона функции следует сразу после main(). 
Листинг 8.11. funterap. срр 
// funtemp.cpp -- использование шаблона функции 
*/
#include <iostream>
template <typename T> // или class Т 
void Swap(T &a, T &b);

int main(void)
{
    using namespace std;
    int i = 10;
    int j = 20;
    cout << "i, j = " << i << ", " << j << ".\n";
    cout << "Using compiler-generated int swapper:\n";
    Swap(i, j); // генерирует void Swap(int &, int &) 
    cout << "Now i, j = " << i << ", " << j << ".\n";
    double x = 24.5;
    double y = 81.7;
    cout << "x, y = " << x << ", " << y << ".\n";
    cout << "Using compiler-generated double swapper:\n";
    Swap(x,y); // генерирует void Swap(double &, double &) 
    cout << "Now x, y = " << x << ", " << y << ".\n";
    // cin.get(); 
    return 0;
}
// Определение шаблона функции 
template <typename T> // или class T 
void Swap(T &a, T &b)
{
    T temp; // temp - переменная типа Т 
    temp = a;
    a = b;
    b = temp;
}
/*
Первая функция Swap() в листинге 8.11 имеет два аргумента типа int, поэтому компилятор генерирует версию функции, предназначенную для обработки данных типа int. 
Другими словами, он заменяет каждое использование т типом int, создавая определение следующего вида: 
void Swap (int &a, int &b) 
{ 
    int temp; 
    temp = a; 
    a = b; 
    b = temp; 
} 
Вы не увидите этот код, но компилятор генерирует его, а затем использует в программе. 
Вторая функция Swap() имеет два аргумента типа double, поэтому компилятор генерирует версию функции, предназначенную для обработки данных double. 
Таким образом, он заменяет все вхождения т типом double, генерируя следующий код: 
void Swap(double &a, double &b) 
{ 
    double temp; 
    temp = a; 
    a = b; 
    b = temp; 
} 
Вывод программы из листинга 8.11 показывает, что все работает, как и ожидалось: 
i, j = 10, 20. 
Using compiler-generated int swapper: 
Now i, j = 20, 10. 
x, у = 24.5, 81.7. 
Using compiler-generated double swapper: 
Now x, у = 81.7, 24.5. 
Обратите внимание, что шаблоны функций не сокращают размеры исполняемых файлов. В листинге 8.11 все по-прежнему завершается двумя отдельными  
определениями функций, как если бы это было реализовано вручную. 
Окончательный код не содержит шаблонов, а содержит реальные функции, сгенерированные для программы. 
Преимущество шаблонов состоит в упрощении процесса генерации нескольких определений функции, а также в увеличении его надежности. 
Чаще всего шаблоны помещаются в заголовочный файл, который затем включается в использующий эти шаблоны файл. Заголовочные файлы обсуждаются в главе 9. 
*/