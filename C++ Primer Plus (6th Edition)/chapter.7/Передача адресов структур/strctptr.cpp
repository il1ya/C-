/* Предположим, что вы хотите сэкономить время и пространство памяти за счет передачи адресов структуры вместо самой структуры. 
Для этого потребуется переписать функции так, чтобы они использовали в качестве аргументов указатели на структуры. 
Давайте посмотрим, как можно переписать функцию show_polar(). Для этого понадобится внести три изменения. 
• При вызове функции передать ей адрес структуры (&pplace) вместо самой структуры (рріасе). 
• Определить формальный параметр как указатель на структуру polar — т.е. polar *. Поскольку функция не должна модифицировать структуру, дополнительно задать модификатор const. 
• Поскольку формальный параметр теперь будет указателем на структуру вместо самой структуры, использовать операцию -> вместо операции точки. 
После внесения этих изменений функция будет выглядеть следующим образом: 
// отображение полярных координат с преобразованием радиан в градусы 
void show_polar (const polar * pda) 
{ 
    using namespace std; 
    const double Rad_to_deg = 57.29577951; 
    cout << "distance = " « pda->distance; 
    cout << ", angle = " « pda->angle * Rad_to_deg; 
    cout << " degrees\n"; 
} 
Теперь изменим rect_to_polar(). Это будет несколько сложнее, потому что исходная функция rect_to_polar () возвращает структуру. 
Чтобы воспользоваться всеми преимуществами эффективности указателей, придется также возвращать указатель вместо значения. 
Для этого необходимо передать функции два указателя на структуру. 
Первый будет указывать на преобразовываемую структуру, а второй — на структуру, содержащую результат преобразования. 
Вместо возврата новой структуры функция модифицирует структуру, существующую в вызывающей функции. 
Поэтому, хотя первый аргумент является константным указателей, второй аргумент — не const. 
Во всем остальном применимы те же принципы, что использовались для  перевода show_polar() к аргументам-указателям. В листинге 7.13 показана переработанная программа. 
Листинг 7.13. strctptr.cpp */
// strctptr.cpp -- функции с аргументами-указателями на структуры 

#include <iostream>
#include <cmath>

// Объявления структур 
struct polar
{
    double distance; // расстояние от исходной точки 
    double angle;    // направление от исходной точки 
};
struct rect
{
    double x;       // расстояние по горизонтали от исходной точки 
    double y;       // расстояние по вертикали от исходной точки 
};
// Прототипы 
void rect_to_polar(const rect *pxy, polar *pda);
void show_polar(const polar *pda);
int main(void)
{
    using namespace std;
    rect rplace;
    polar pplace;
    cout << "Enter the x and y values: ";  // ввод значений х и у 
    while(cin >> rplace.x >> rplace.y)
    {
        rect_to_polar(&rplace, &pplace);    // передача адресов 
        show_polar(&pplace);                // передача адресов 
        cout << "Next two numbers (q to quit): ";
        // Ввод следующих двух чисел (q для завершения) 
    }
    cout << "Done.\n";
    return 0;
}

// Отображение полярных координат с преобразованием радиан в градусы 
void show_polar (const polar *pda)
{
    using namespace std;
    const double Rad_to_deg = 57.29577951;
    cout << "distance = " << pda -> distance;
    cout << ", angle = " << pda -> angle * Rad_to_deg;
    cout << "degrees\n";
}
// Преобразование прямоугольных координат в полярные 
void rect_to_polar(const rect *pxy, polar *pda)
{
    using namespace std;
    pda -> distance = sqrt(pxy->x *pxy->x + pxy->y * pxy->y);
    pda->angle = atan2(pxy->y, pxy->x);
}
/*
На заметку! 
Некоторые компиляторы требуют явных инструкций для нахождения математической библиотеки. 
Например, для вызова старых версий д++ должна использоваться следующая командная строка: 
g++ structfun.C -lm 
С точки зрения пользователя программа из листинга 7.13 ведет себя точно так же, как программа из листинга 7.12. 
Скрытое отличие в том, что программа из листинга 7.12 работает с копиями структур, в то время как программа из листинга 7.13 использует указатели, позволяя функциям оперировать на исходных структурах. 
*/