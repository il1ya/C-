/* Хорошо ли то, что между именами массивов и указателями имеется соответствие? 
Безусловно. Проектное решение, связанное с использованием адресов массивов в качестве аргументов, позволит сэкономить время и память, необходимую для копирования всего массива. 
При работе с большими массивами накладные расходы, возникающие из-за использования таких копий, могли бы оказаться весьма ощутимыми. 
С копиями программам понадобилось бы не только больше компьютерной памяти, но и больше времени на копирование крупных блоков данных. 
С другой стороны, работа с исходными данными чревата возможностью непреднамеренного их повреждения. 
Это — реальная проблема в классическом С, но в ANSI С и C++ предусмотрен модификатор const, который обеспечивает необходимую защиту. 
Скоро вы увидите пример. 
Но сначала давайте изменим код в листинге 7.5, чтобы проиллюстрировать некоторые моменты, связанные с тем, как работают функции массивов. 
Программа в листинге 7.6 демонстрирует, что cookie и аrr содержат одни и те же значения. 
Она также показывает, что концепция указателей делает функцию sum_arr() более изменчивой и гибкой, нежели могло показаться вначале. 
Чтобы внести немного разнообразия, для обеспечения доступа к cout и endl в программе применяется квалификатор std:: вместо директивы using. 
Листинг 7.6. arrfun2.срр */
// arrfun2.срр -- функция с аргументом-массивом 
#include <iostream>
const int ArSize = 8;
int sum_arr(int arr[], int n);
// использование std:: вместо директивы using
int main(void)
{
    int cookies[ArSize] = {1,2,4,8,16,32,64,128};
    // Некоторые системы требуют предварить int словом static, 
    // чтобы разрешить инициализацию массива 
    std::cout << cookies << " = array address, ";
    // Некоторые системы требуют приведения типа: unsigned (cookies) 
    std::cout << sizeof cookies << " = sizeof cookies\n";
    int sum = sum_arr(cookies, ArSize);
    std::cout  << "Total cookies eaten: " << sum << std::endl;
        // Общее количество съеденного печенья 
    sum = sum_arr(cookies, 3);              // первая хитрость 
    std::cout << "First three eaters ate " << sum << " cookies.\n";
        // Съеденное первыми тремя 
    sum = sum_arr(cookies + 4, 4);          // вторая хитрость 
    std::cout << "Last four eaters ate " << sum << " cookies.\n";
        // Съеденное последними четырьмя 
    return 0;
}

// Возвращает сумму элементов целочисленного массива 
int sum_arr(int arr[], int n)
{
    int total = 0;
    std::cout << arr << " = arr, ";
    // Некоторые системы требуют приведения типа: unsigned (arr) 
    std::cout << sizeof arr << " = sizeof arr\n";
    for(int i = 0; i < n; i++)
        total = total + arr[i];
        return total;
}
/*
Обратите внимание, что значения адресов и размеров могут изменяться от системы к системе. 
К тому же, некоторые реализации отображают адреса в десятичной системе, а не в шестнадцатеричной. 
Другие реализации будут использовать шестнадцатеричные цифры и префикс 0х. 
Замечания по программе 
Код в листинге 7.6 иллюстрирует некоторые очень интересные моменты, касающиеся функций, которые работают с массивами. 
Для начала обратите внимание, что cookies и arr, как и утверждалось, находятся по одному и тому же адресу в памяти. 
Но sizeof cookies равно 32, в то время как sizeof arr составляет 4. Причина в том, что sizeof cookies — размер всего массива, тогда как sizeof arr — размер переменной-указателя. 
(Программа выполнялась в системе с 4-байтными адресами.) Кстати, именно поэтому B.sum_arr() нужно передавать размер массива вместо sizeof arr: 
указатель сам по себе не отражает размер массива. 
Поскольку единственный способ для sum_arr() узнать количество элементов в массиве — через второй аргумент, вы можете схитрить. 
Например, второй вызов функции выглядит следующим образом: 
sum = sum_arr(cookies, 3); 
Сообщая функции, что cookies имеет только три элемента, вы заставляете ее подсчитать сумму первых трех элементов. 
Но зачем на этом останавливаться? Вы можете также схитрить относительно местоположения массива: 
sum = sum_arr (cookies + 4, 4) ; 
Поскольку cookies является адресом первого элемента, то cookies + 4 — адрес пятого элемента. 
Этот оператор суммирует пятый, шестой, седьмой и восьмой элементы массива. 
Следует отметить, что при третьем вызове функции передается другой адрес arr, отличный от того, что был передан в первых двух вызовах. 
Конечно же, в качестве аргумента можно было бы использовать & cookies [4] вместо cookies + 4 — оба варианта означают одно и то же. 
*/