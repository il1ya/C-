/* До сихпорвсе примеры функций, приведенные в данной книге, были простыми и использовали для своих аргументов и возвращаемых значений только базовые типы. 
Однако функции могут служить инструментами и для обработки более сложных типов, таких как массивы и структуры. 
Давайте посмотрим, как соотносятся друг с другом массивы и функции. 
Предположим, что вы используете массив, чтобы отследить, сколько печенья съел каждый участник семейного пикника. 
(Каждый индекс массива соответствует определенному лицу, а значение элемента — количеству съеденного печенья.) 
Необходим также общий итог. Его легко вычислить: нужно просто применить цикл для суммирования всех элементов массива. 
Но сложение элементов массива — настолько часто встречающаяся операция, что имеет смысл спроектировать функцию для решения этой задачи. 
Тогда вам не придется писать новый цикл каждый раз, когда понадобится суммировать элементы массива. 
Давайте посмотрим, как должен выглядеть интерфейс функции. Поскольку функция вычисляет сумму, она должна возвращать ответ. 
Если вы поглощаете печенье целиком, то можно использовать функцию с типом возврата int. 
Чтобы функция знала, какой массив суммировать, ей понадобится передавать в качестве аргумента имя массива. 
И чтобы не ограничивать ее массивами определенного размера, нужно будет также передавать ей размер массива. 
Единственный новый ингредиент здесь — это имя массива в качестве одного из формальных аргументов. Давайте посмотрим, что получилось: 
int sum_arr(int arr[], int n) // arr = имя массива, п = размер 
Выглядит вполне правдоподобно. Квадратные скобки указывают на то, что arr — массив, а тот факт, что они пусты, говорит о том, что эту функцию можно применять 
с массивами любого размера. Но бывает, что некоторые вещи не являются тем, чем кажутся: arr — на самом деле не массив, а указатель! Однако хорошей новостью будет 
то, что остальную часть функции можно записать так, как если бы аргумент arr все- таки был массивом. Для начала убедимся на примере, что такой подход работает, а потом разберемся, почему. 
В листинге 7.5 иллюстрируется применение указателя, как если бы он был именем массива. Программа инициализирует массив некоторыми значениями и затем  
использует функцию sum_arr() для вычисления суммы. Обратите внимание, что sum_arr() работает с arr, как если бы он был именем массива. 
Листинг 7.5. arrfunl.срр */
// arrfunl.срр -- функция с аргументом-массивом 
#include <iostream>
const int ArSize = 8;
int sum_arr(int arr[], int n); // прототип
int main(void)
{
    using namespace std;
    int cookies[ArSize] = {1,2,4,8,16,32,64,128};
    // Некоторые системы требуют предварить int словом static, 
    // чтобы разрешить инициализацию массива 
    int sum = sum_arr(cookies, ArSize);
    cout << "Total cookies eaten: " << sum << "\n"; // вывод количества съеденного печенья 
    return 0;
}

// Возвращает сумму элементов массива целых чисел 
int sum_arr(int arr[], int n)
{
    int total = 0;
    for(int i = 0; i < n; i++)
        total = total + arr[i];
        return total;
}