/*
Собираем все вместе 321-324
Теперь, когда данные определены в терминах их хранения (массив), а также в терминах их использования (три функции), можно собрать вместе программу, использующую это проектное решение. 
Поскольку все операции управления массивом уже реализованы, это значительно упрощает программирование main(). 
Программа должна проверить, ввел ли пользователь число в ответ на запрос коэффициента переоценки. 
Вместо того чтобы останавливать выполнение в случае некорректного ввода, организуется цикл, запрашивающий у пользователя правильное значение коэффициента. 
Большая часть оставшейся работы по программированию сводится к вызовам разработанных функций в теле main(). 
В листинге 7.7 показан результат сборки всех частей. Директива using находится только в тех функциях, в которых применяются средства iostream. 
Листинг 7.7. arrfun3.cpp */
// arrfun3.cpp -- функция работы с массивами и применение const 
#include <iostream>
const int Max = 5;

// Прототипы функций
int fill_array(double ar[], int limit);
void show_array(const double ar[], int n);                // не изменять данные
void revalue(double r, double ar[], int n);
int main(void)
{
    using namespace std;
    double properties[Max];
    int size = fill_array(properties, Max);
    show_array(properties, size);
    if(size > 0)
    {
        cout << "Enter revaluation factor: ";             // ввод коэффициента переоценки
        double factor;
        while(!(cin >> factor))                           // неправильный ввод 
        {
            cin.clear();
            while(cin.get() != '\n')
            continue;
            cout << "Bad input; Please enter a number: "; // повторный запрос на ввод числа 
        }
        revalue(factor, properties, size);
        show_array(properties, size);
    }
    cout << "Done.\n";
    cin.get();
    cin.get();
    return 0;
}

int fill_array(double ar[], int limit)
{
    using namespace std;
    double temp;
    int i;
    for(i = 0; i < limit; i++)
    {
        cout << "Enter value #" << (i + 1) << ": ";             // ввод значения 
        cin >> temp;
        if(!cin)                                                // неправильный ввод 
        {
            cin.clear();
            while(cin.get() != '\n')
            continue;
            cout << "Bad input; input process terminated.\n";   // процесс ввода прекращен 
            break;
        }
        else if(temp < 0)                                       // сигнал завершения 
        break;
        ar[i] = temp;
    }
    return i;
}

// Следующая функция может использовать, но не изменять, массив по адресу аг 
void show_array(const double ar[], int n)
{
    using namespace std;
    // Вывод содержимого массива аг 
    for(int i = 0; i < n; i++)
    {
        cout << "Property #" << (i + 1) << ": $";
        cout << ar[i] << endl;
    }
}

// Умножает на r каждый элемент аr[] 
void revalue(double r, double ar[], int n)
{
    for(int i = 0; i < n; i++)
        ar[i] *= r;
}
/*
Вспомните, что fill_array() предполагает прекращение ввода, когда пользователь введет пять элементов либо отрицательное значение — в зависимости от того, что произойдет раньше. 
Первый пример вывода иллюстрирует достижение предела по количеству элементов, а второй — прекращение приема значений по вводу  отрицательной величины. 
Замечания по программе 
Мы уже обсудили важные детали программирования примера, поэтому обратимся к процессу в целом. 
Мы начали с обдумывания типа данных и разработали соответствующий набор функций для их обработки. 
Затем мы встроили эти функции в программу. Это то, что иногда называют восходящим программированием, поскольку процесс проектирования идет от частей-компонентов к целому. 
Этот подход хорошо стыкуется с объектно-ориентированным программированием (ООП), которое сосредоточено в первую очередь на данных и манипуляциях ими. 
Традиционное процедурное программирование, с другой стороны, следует парадигме нисходящего программирования, когда сначала разрабатывается укрупненная модульная структура, а затем внимание 
переключается на детали. 
Оба метода полезны и оба ведут к получению модульных программ. 

*/