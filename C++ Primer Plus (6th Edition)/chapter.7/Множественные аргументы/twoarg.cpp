/* Функция может принимать более одного аргумента. При вызове функции такие аргументы просто отделяются друг от друга запятыми: 
n_chars('R', 25); 
Это передает два аргумента функции n_chars(), определение которой будет приведено чуть позже. 
Аналогично, при определении функции используется разделенный запятыми список параметров в ее заголовке: 
void n_chars(char с, int n) // два параметра 
Этот заголовок устанавливает, что функция n_chars () принимает один параметр типа char; и один типа int. 
Параметры сип инициализируются значениями, переданными функции. Если функция имеет два параметра одного и того же типа, то типы каждого параметра должны указываться по отдельности. 
Комбинирование объявлений аргументов, как это делается с обычными переменными, не допускается: 
void fifi(float a, float b) // объявляет каждую переменную отдельно 
void fufu(float a, b) // не допускается 
Как и в случае других функций, для получения прототипа нужно просто добавить точку с запятой: 
void n_chars(char с, int n); // прототип, стиль 1 
Подобно ситуации с единственным аргументом, вы не обязаны использовать одинаковые имена переменных в прототипе и определении. 
Также можно опускать имена переменных в прототипе: 
void n_chars(char, int); // прототип, стиль 2 
Тем не менее, указание имен переменных часто помогает прояснить прототип, особенно если два параметра имеют один и тот же тип. 
Впоследствии имена параметров будут напоминать, какой аргумент для чего предназначен: 
double melon_density(double weight, double volume); 
В листинге 7.3 представлен пример функции с двумя аргументами. Он также иллюстрирует тот факт, что изменение значения формального параметра внутри функции 
никак не влияет на данные вызывающей программы. 
Листинг 7.3. twoarg. срр */ 
// twoarg.срр -- функция с двумя аргументами 
#include <iostream>
using namespace std;
void n_chars(char, int);
int main(void)
{
    int times;
    char ch;
    cout << "Enter a character: ";                      // ввод символа 
    cin >> ch;
    while(ch != 'q')                                    // q для завершения 
    {
        cout << "Enter an integer: ";                   // ввод целого числа 
        cin >> times;
        n_chars(ch, times);                             // функция с двумя аргументами 
        cout << "\nEnter another character or press the"
                "q-key to quit: ";                      // ввод другого символа или q для завершения 
        cin >> ch;
    }
    cout << "The value of times is " << times << ".\n"; // вывод значения переменной times 
    cout << "Bye!\n";
    return 0;
}

void n_chars(char c, int n) // вывод значения с п раз 
{
    while(n-- > 0) // продолжение, пока п не достигнет 0 
    cout << c;
}

// Программа в листинге 7.3 иллюстрирует помещение директивы using над определением функции вместо ее использования внутри функции. 