/* Как вы уже видели, функции C++, обрабатывающие массивы, нуждаются в информации относительно типа данных, хранящихся в массиве, местоположения его начала и количества его элементов. 
Традиционный подход C/C++ к функциям, обрабатывающим массивы, состоит в передаче указателя на начало массива в одном аргументе и размера массива — в другом. 
(Указатель сообщает функции и то, где искать массив, и тип его элементов.) 
Это предоставляет функции исчерпывающую информацию, необходимую для нахождения данных. 
Существует другой подход к предоставлению функции нужной информации —  указание диапазона элементов. Это можно сделать, передав два указателя — один,  
идентифицирующий начальный элемент массива, и второй, указывающий его конец. 
Стандартная библиотека шаблонов C++ (STL; рассматривается в главе 16), например, обобщает такой подход с применением диапазона. 
Подход STL использует концепцию "следующий после конца" для указания границы диапазона. 
То есть в случае массива аргументом, идентифицирующим конец массива, должен быть указатель, который установлен на адрес, следующий сразу за последним элементом. 
Например, предположим, что имеется такое объявление: 
double elbuod[20]; 
Диапазон определяют два указателя — elbuod и elbuod + 20. Первый — elbuod — это имя массива; он указывает на первый элемент. 
Выражение elbuod +19 указывает на последний элемент (т.е. elbuod [19]), поэтому elbuod + 20 указывает на элемент, следующий сразу за последним. 
Передавая функции диапазон, вы сообщаете ей, какие элементы должны обрабатываться. 
В листинге 7.8 приведен измененный код из листинга 7.6, в котором используются два указателя для задания диапазона. 
Листинг 7.8. arrfun4.срр */
// arrfun4.срр — функция с диапазоном массива 
#include <iostream>
const int ArSize = 8;
int sum_arr(const int *begin, const int *end);
int main(void)
{
    using namespace std;
    int cookies[ArSize] = {1,2,4,8,16,32,64,128};
    // Некоторые системы требуют предварить int словом static, 
    // чтобы разрешить инициализацию массива 
    int sum = sum_arr(cookies, cookies + ArSize);
    cout << "Total cookies eaten: " << sum << endl;
    sum = sum_arr(cookies, cookies + 3);                        // три первых элемента 
    cout << "First three eaters ate " << sum << " cookies.\n";
    sum = sum_arr(cookies + 4, cookies + 8);                    // четыре последних элемента 
    cout << "Last four eaters ate " << sum << " cookies.\n";
    return 0;
}
// Возвращает сумму элементов целочисленного массива 
int sum_arr(const int *begin, const int *end)
{
    const int *pt;
    int total = 0;
    for(pt = begin; pt != end; pt++)
        total = total + *pt;
        return total;
}
/*
Замечания по программе 
В листинге 7.8 обратите внимание на цикл внутри функции sum_array(): 
for (pt = begin; pt != end; pt++) 
total = total + *pt; 
Здесь указатель pt устанавливается на первый обрабатываемый элемент (на который указывает begin) и прибавляет *pt (значение самого элемента) к общей сумме total. 
Затем цикл обновляет pt, увеличивая его на единицу, после чего он указывает на следующий элемент. 
Процесс продолжается до тех пор, пока pt != end. Когда pt, наконец, становится равным end, он указывает на позицию, следующую за последним элементом диапазона, поэтому цикл завершается. 
Второе, что следует отметить — это то, как разные вызовы функций задают различные диапазоны в пределах массива: 
int sum = sum_arr(cookies, cookies + ArSize); 
sum = sum_arr (cookies, cookies + 3); // три первых элемента 
sum = sum_arr(cookies + 4, cookies +8); // четыре последних элемента 
Значение cookies + ArSize указывает на позицию, следующую за последним элементом массива. 
(Массив содержит ArSize элементов, потому cookies [ArSize-1] является последним элементом с адресом cookies + ArSize - 1.) 
Поэтому диапазон cookies, cookies + ArSize определяет весь массив. Аналогично cookies, cookies + 3 означает первые три элемента и т.д. 
Кстати, обратите внимание, что согласно правилам вычитания указателей, в sum_arr() выражение end - begin дает целочисленное значение, равное количеству элементов в диапазоне. 
Кроме того, важно передавать указатели в корректном порядке; в коде предполагается, что end поступает после begin. 
*/