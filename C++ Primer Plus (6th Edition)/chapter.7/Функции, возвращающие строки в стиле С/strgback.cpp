/* Теперь предположим, что требуется написать функцию, возвращающую строку. 
Конечно, функция может это сделать. Но она может вернуть адрес строки, и это наиболее эффективно. Например, листинг 7.10 определяет функцию buildstr(),  
возвращающую указатель. Эта функция принимает два аргумента: символ и число. 
Используя new, она создает строку, длина которой равна переданному числу, и инициализирует каждый ее элемент значением переданного символа. 
Затем она возвращает указатель на эту новую строку. 
*/
#include <iostream>
char *buildstr(char c, int n);      // прототип
int main(void)
{
    using namespace std;
    int times;
    char ch;
    cout << "Enter a character: ";  // ввод символа 
    cin >> ch;
    cout << "Enter an integer: ";   // ввод целого числа 
    cin >> times;
    char *ps = buildstr(ch, times);
    cout << ps << endl;
    delete [] ps;                  // освобождение памяти 
    ps = buildstr('+', 20);        // повторное использование указателя 
    cout << ps << "-DONE-" << ps << endl;
    delete [] ps;                  // освобождение памяти 
    return 0;
}

// Строит строку из п символов с 
char *buildstr(char c, int n)
{
    char *pstr = new char[n + 1];
    pstr[n] = '\0';             // завершение строки 
    while(n--> 0)
        pstr[n] = c;            // заполнение остатка строки 
        return pstr;
}
/*
Замечания по программе 
Чтобы создать строку из п видимых символов, понадобится разместить п + 1 символов, с учетом нулевого символа-ограничителя. 
Поэтому функция в листинге 7.10 запрашивает п + 1 байт для размещения строки. 
Далее она устанавливает последний байт в нулевой символ. 
После этого наполняет массив от конца к началу. Следующий цикл в листинге 7.10 выполняется п раз — уменьшая п до 0 и заполняя п элементов: 
while (n— > 0) 
pstr[n] = с; 
Перед началом последнего прохода цикла п имеет значение 1. Поскольку п— означает использовать значение, а потом инкрементировать его, условие цикла while 
проверяет 1 на равенство 0, возвращает true, и цикл продолжается. Но после выполнения этой проверки функция уменьшает п до 0, поэтому pstr [0] — последний элемент, которому присваивается с. 
Причина наполнения строки от конца к началу вместо того, чтоб наполнять от начала к концу, связана с желанием избежать применения дополнительной переменной. 
Использование противоположного порядка потребовало бы примерно такого кода: 
int i = 0; 
while (i < n) 
pstr[i++] = c; 
Обратите внимание, что переменная pstr является локальной по отношению к функции buildstr(), поэтому, когда эта функция завершается, память, занятая pstr (но не самой строкой), освобождается. 
Но поскольку функция возвращает значение pstr, программа имеет возможность получить доступ к новой строке через указатель ps в main(). 
Программа из листинга 7.10 применяет delete, чтобы освободить память, когда необходимость в строке отпадает. Затем она повторно использует ps, чтобы указать 
на новый блок памяти, полученный для следующей строки, и снова освобождает ее. Недостаток такого подхода (функция, возвращающая указатель на память, выделенную операцией new) 
состоит в том, что он возлагает на программиста ответственность за вызов delete. 
В главе 12 вы увидите, что классы C++ за счет использования конструкторов и деструкторов могут самостоятельно позаботиться об этих деталях. 
*/