/* Рекурсия с одиночным рекурсивным вызовом 
Если рекурсивная функция вызывает саму себя, затем этот новый вызов снова вызывает себя и т.д., то получается бесконечная последовательность вызовов, если 
только код не включает в себе нечто, что позволит завершить эту цепочку вызовов. 
Обычный метод состоит в том, что рекурсивный вызов помещается внутрь оператора if. Например, рекурсивная функция типа void по имени recurs() может иметь следующую форму: 
void recurs(списокАргументов) 
{ 
    операторыі 
    if (проверка) 
    recurs {аргументы) 
    операторы2 
} 
В какой-то ситуации проверка возвращает false, и цепочка вызовов прерывается. Рекурсивные вызовы порождают замечательную цепочку событий. 
До тех пор, пока условие оператора if остается истинным, каждый вызов recurs() выполняет операторыі и затем вызывает новое воплощение recurs(), не достигая конструкции операторы2. 
Когда условие оператора if возвращает false, текущий вызов переходит к операторы2. 
Когда текущий вызов завершается, управление возвращается предыдущему экземпляру recurs(), который вызвал его. 
Затем этот экземпляр выполняет свой раздел операторы2 и прекращается, возвращая управление предшествующему вызову, и т.д. 
Таким образом, если происходит пять вложенных вызовов recurs(), то первый раздел операторыі выполняется пять раз в том порядке, в котором  
произошли вызовы, а потом пять раз в обратном порядке выполняется раздел операторы2. 
После входа в пять уровней рекурсии программа должна пройти обратно эти же пять уровней. Код в листинге 7.16 демонстрирует описанное поведение. 
Листинг 7.16. recur.срр */
// recur.срр — использование рекурсии 
#include <iostream>
void countdown(int n);
int main(void)
{
    countdown(4);       // вызов рекурсивной функции 
    return 0;
}
void countdown(int n)
{
    using namespace std;
    cout << "Counting down ... " << n << endl;
    if(n > 0)
        countdown(n-1); // функция вызывает сама себя 
        cout << n << ": Kaboom!\n";
}
/*
Обратите внимание, что каждый рекурсивный вызов создает собственный набор переменных, поэтому на момент пятого вызова она имеет пять отдельных переменных по имени п — каждая с собственным значением. 
Вы можете убедиться в этом, модифицировав код в листинге 7.16 таким образом, чтобы отображать адрес п наряду со значением: 
cout « "Counting down 
« n « " (n at " « &n « ") " « endl; 
cout « n « ": Kaboom!"; « " (n at " << &n « ")" « endl; 
*/