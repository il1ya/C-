/* Объекты классов в C++ основаны на структурах, поэтому некоторые из соглашений, принятых для структур, применимы также и к классам. 
Например, функции можно передать объект по значению, и тогда она будет действовать на копии исходного объекта. 
В качестве альтернативы можно передать указатель на объект, что позволит функции оперировать на исходном объекте. 
Давайте рассмотрим пример использования шаблонного класса array из С++11. 
Предположим, что имеется объект array, предназначенный для хранения расходов по четырем временам года: 
std::array<double, 4> expenses; 
(Вспомните, что использование класса array требует включения заголовочного файла array, а имя array является частью пространства имен std.) 
Если функция должна просто отобразить содержимое expenses, можно передать этот объект по значению: 
show(expenses); 
Но если функция должна модифицировать объект expenses, ей понадобится передать адрес этого объекта: 
fill(Sexpenses); 
(В следующей главе обсуждается альтернативный подход, предусматривающий применение ссылок.) 
Точно такой же подход использовался для структур в листинге 7.13. Как могут быть объявлены эти две функции? 
Типом expenses является array<double, 4>, поэтому вот как должны выглядеть их прототипы: 
void show (std::array<double, 4> da); // da - объект 
void fill(std::array<double, 4> * pa); // pa — указатель на объект 
Приведенные выше соображения формируют основу примера программы. 
Дополнительно в программе реализовано несколько других возможностей. Во-первых, значение 4 заменяется символической константой: 
const int Seasons = 4; 
Во-вторых, добавляется константный объект array, содержащий четыре объекта string для представления времен года: 
const std::array<std::string, Seasons> Snames = {"Spring", "Summer", "Fall", "Winter"}; 
Обратите внимание, что шаблон array не ограничен хранением базовых типов данных; он может также хранить типы классов. 
Полный код примера программы приведен в листинге 7.15. 
Листинг 7.15. arrobj.срр */
//arrobj.cpp - функции с объектами array (С++11) 
#include <iostream>
#include <array>
#include <string>
// Константные данные 
const int Seasons = 4;
const std::array<std::string, Seasons> Snames = {"Spring", "Summer", "Fall", "winter"};
// Функция для изменения объекта array 
void fill(std::array<double, Seasons> * pa);
// Функция, использующая объект array, но не изменяющая его 
void show(std::array<double, Seasons> da);
int main(void)
{
    std::array<double, Seasons> expenses;
    fill(&expenses);
    show(expenses);
    return 0;
}
void fill(std::array<double, Seasons> * pa)
{
    using namespace std;
    for(int i = 0; i < Seasons; i++)
    {
        cout << "Enter " << Snames[i] << " expenses: "; // ввод расходов по временам года 
        cin >> (*pa)[i];
    }
}
void show(std::array<double, Seasons> da)
{
    using namespace std;
    double total = 0.0;
    cout << "\nEXPENSES\n";                     // вывод расходов по временам года 
    for(int i = 0; i < Seasons; i++)
    {
        cout << Seasons[i] << ": $" << da[i] << endl;
        total += da[i];
    }
    cout << "Total Expenses: $" << total << endl; // вывод общей суммы расходов 
}
/*
Замечания по программе 
Поскольку константный объект array по имени Snames объявлен перед всем функциями, он может применяться в любом следующем за ним объявлении функции. 
Подобно константе Seasons, объект Snames совместно используется во всем файле исходного кода. 
В программе отсутствует директива using, поэтому array и string должны применяться с квалификатором str::. 
Что излишне не усложнять программу и сконцентрировать внимание на том, как функции работают с объектами, никаких проверок допустимости вводимых пользователем данных в функции fill() не предпринимается. 
Функции fill() и show() имеют недостатки. 
Проблема, связанная с функцией show(), состоит в том, что expenses хранит четыре значения double, и создавать новый объект этого размера с последующим копированием в него значений expenses неэффективно. 
Эта проблема еще больше усугубится, если мы модифицируем программу для обработки расходов на ежемесячной или ежедневной основе и соответствующим образом расширим expenses. 
Функция fill() избегает этой проблемы неэффективности за счет использования указателя, так что она оперирует-на исходном объекте. 
Однако платой за это будет применение нотации, которая выглядит более сложной: 
fill(&expenses); // не забывайте о & 
сіп » (*ра) [і] ; 
В последнем операторе ра — это указатель на объект array<double, 4>, поэтому *ра является объектом, а (*ра) [і] — элементом в этом объекте. 
Круглые скобки необходимы для соблюдения приоритета операций. Логика очень проста, но в результате увеличиваются возможности допустить ошибку. 
Как будет показано в главе 8, применение ссылок помогает решить и проблему эффективности, и проблему усложненной нотации. 
*/