/* 
В листинге 14.13 приведены комбинированные шаблоны класса и функций-членов. 
Важно понимать, что эти шаблоны не являются определениями классов и функций-членов. 
Это скорее указания компилятору C++, как сгенерировать определения класса и функций-членов. 
Конкретная актуализация шаблона — например, класс стека для управления объектами string — называется созданием экземпляра или специализацией. 
Шаблонные функции-члены нельзя размещать в отдельном файле реализации. (Одно время в стандарте языка существовало ключевое слово export, которое позволяло такой вынос в отдельный файл реализации. 
Однако оно не было учтено в очень многих реализациях. В С++11 это слово уже не входит в стандарт, но зарезервировано для возможного дальнейшего использования.) 
Поскольку шаблоны не являются функциями, их нельзя компилировать отдельно. Шаблоны необходимо применять совместно с запросами на создание экземпляров шаблонов. 
Проще всего это сделать, поместив всю информацию о шаблонах в заголовочный файл и включив этот заголовочный файл в файл, использующий шаблоны. 
Листинг 14.13. stacktp.h */
// stacktp.h — шаблон стека 

#ifndef STACKTP_H_
#define STACKTP_H_

template <class Type>

class Stack
{
    private:
        enum {MAX = 10};                // константа, специфичная для класса 
        Type items[MAX];                // содержит элементы стека 
        int top;                        // индекс вершины стека 
    public:
        Stack();
        bool isempty();
        bool isfull();
        bool push(const Type &item);    // индекс вершины стека 
        bool pop(Type &item);           // выталкивание из стека в item 
};

template <class Type>
Stack<Type>::Stack()
{
    top = 0;
}

template <class Type>
bool Stack<Type>::isempty()
{
    return top == 0;
}

template <class Type>
bool Stack<Type>::isfull()
{
    return top == MAX;
}

template <class Type>
bool Stack<Type>::push(const Type &item)
{
    if(top < MAX)
    {
        items[top++] = item;
        return true;
    }
    else
        return false;
}

template <class Type>
bool Stack<Type>::pop(Type &item)
{
    if(top > 0)
    {
        item = items[--top];
        return true;
    }
    else
        return false;
}
#endif
