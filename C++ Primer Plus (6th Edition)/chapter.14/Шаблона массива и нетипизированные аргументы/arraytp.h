/* Шаблоны часто используются для контейнерных классов, поскольку идея параметров типа удачно сочетается с идеей общего способа хранения для различных типов. 
На самом деле стремление предоставить повторно используемый код для контейнерных классов и было главной причиной введения шаблонов. 
Рассмотрим другой пример и исследуем несколько новых аспектов разработки и применения шаблонов. 
А именно, рассмотрим нетипизированные аргументы, или аргументы-выражения, и применение массива для управления семейством наследования. 
Начнем с простого шаблона массива, который позволяет задавать размер массива. 
Один из приемов, который был использован в последней версии шаблона Stack — использование динамического массива внутри класса и аргумента в конструкторе для задания количества элементов. 
Другой подход состоит в применении аргумента шаблона для задания размера обычного массива, и как раз так поступает новый шаблон array в С++11. 
В листинге 14.17 приведена более скромная версия. 
Листинг 14.17. arraytp.h */
// arraytp.h — шаблон массива 

#ifndef ARRAYTP_H_
#define ARRAYTP_H_

#include <iostream>
#include <cstdlib>

template <class T, int n>

class ArrayTP
{
    private:
        T ar[n];
    public:
        ArrayTP() {};
        explicit ArrayTP(const T &v);
        virtual T &operator[](int i);
        virtual T  operator[](int i) const;
};

template <class T, int n>
ArrayTP<T, n>::ArrayTP(const T & v)
{
    for(int i = 0; i < n; i++)
        ar[i] = v;
}
template <class T, int n>
T & ArrayTP<T,n>::operator[](int i)
{
    if(i < 0 || i >= n)
    {
        std::cerr << "Error in array limits: " << i     // выход за пределы допустимого 
                  << " is out of range\n";              // диапазона индекса в массиве 
        std::exit(EXIT_FAILURE);
    }
    return ar[i];
}

template <class T, int n>
T ArrayTP<T, n>::operator[](int i) const
{
    if(i < 0 || i >= n)
    {
        std::cerr << "Error in array limits: " << i     // выход за пределы допустимого 
                  << " is out of range\n";              // диапазона индекса в массиве 
        std::exit(EXIT_FAILURE);
    }
    return ar[i];
}

#endif