/* Шаблоны-члены 
Шаблоны могут быть членами структуры, класса или шаблонного класса. Эти  свойства необходимы библиотеке STL для полного определения своей структуры. 
В листинге 14.20 приведен небольшой пример шаблонного класса с вложенными в виде членов шаблонным классом и шаблонной функцией. 
Листинг 14.20. tempmemb.cpp */
// tempmemb.срр - шаблоны-члены 
#include <iostream>

using std::cout;
using std::endl;

template <typename T>

class beta
{
    private: 
        template <typename V>   // вложенный шаблонный класс-член 
        class hold
        {
            private:
                V val;
            public:
                hold(V v = 0) : val(v) {}
                void show() const { cout << val << endl;}
                V Value() const {return val;}
        };
        hold<T> q;      // шаблонный объект 
        hold<int> n;    // шаблонный объект 
    public:
        beta(T t, int i) : q(t), n(i) {}
        template<typename U> // шаблонный метод 
        U blab(U u, T t) {return (n.Value() + q.Value()) * u / t;}
        void Show() const {q.show(); n.show();}
};
int main()
{
    beta<double> guy(3.5, 3);
    cout << "T was set to double\n";    // T установлен в double 
    guy.Show();
    cout << "V was set to T, which is double, then V was set to int\n";
            // V установлен в Т, который double, затем V установлен в int 
    cout << guy.blab(10, 2.3) << endl;
    cout << "U was set to int\n";       // U установлен в int 
    cout << guy.blab(10.0, 2.3) << endl;
    cout << "U was set to double\n";    // U установлен в double 
    cout << "Done\n";
    return 0;
    
}

/*
Шаблон hold объявлен в закрытом разделе, поэтому он доступен только в пределах класса beta. 
Класс beta использует шаблон hold для определения двух членов данных: 
hold<T> q;      // шаблонный объект 
hold<int> n;    // шаблонный объект 
п — объект hold, основанный на типе int, а член q — объект hold, основанный на типе Т (параметр шаблона beta). 
Следующее объявление в функции main() присваивает Т тип double, a q — тип hold<double>: 
beta<double> guy(3.5, 3); 
В методе blab() один тип (U) определен неявно, с помощью значения аргумента при вызове метода, а другой тип- (Т) определен типом создания экземпляра объекта. 
В данном примере объявление для guy назначает Т тип double. Первый аргумент при вызове метода в следующем операторе назначает U тип int, соответствующий значению 10: 
cout « guy. blab (10, 2.5) « endl; 
Таким образом, хотя автоматическое преобразование типов из-за смешения типов приводит к вычислению blab() как double, возвращаемое значение, имеющее тип U, должно быть int.
Поэтому оно усекается до 28, как показано в выводе программы: 
Т was set to double 
3.5 
3 
V was set to T, which is double, then V was set to int 
28 
U was set to int 
28.2609 
U was set to double 
Done 
Если в вызове guy.blab() заменить 10 на 10.0, то тип U будет установлен в double, поэтому типом возврата будет double, о чем говорит наличие 28.2609 в выводе. 
Как упоминалось ранее, тип второго параметра в определении объекта guy устанавливается в double. 
Но в отличие от первого параметра, тип второго параметра не задается вызовом функции. Например, показанный ниже оператор по-прежнему 
реализует blah() как blah(int, double), и значение 3 будет преобразовано в тип double по обычным правилам соответствия прототипам функций: 
cout << guy.blab (10, 3) << endl; 
Можно объявить класс hold и метод blah в шаблоне beta и определить их за пределами этого шаблона. 
Правда, некоторые старые компиляторы вообще не воспринимают шаблоны-члены, а другие допускают их в том виде, который представлен в листинге 14.20, но не разрешают определять вне класса. 
*/