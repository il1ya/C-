/*
Короче говоря, ниже представлены основные шаги, связанные с использованием файлового вывода. 
1. Включить заголовочный файл f stream. 
2. Создать объект of stream. 
3. Ассоциировать объект of stream с файлом. 
4. Работать с объектом of stream в той же манере, как с cout. 
Этот подход демонстрируется в листинге 6.15. У пользователя запрашивается информация, вывод посылается сначала на экран, а затем в файл. 
Полученный файл можно просмотреть в текстовом редакторе. 
Листинг 6.15. outfііе.срр */
// outfile.cpp -- запись в файл 

#include <iostream>
#include <fstream> // для файлового ввода-вывода
int main(void)
{
    using namespace std;
    char automobile[50];
    int year;
    double a_price;
    double d_price;
    ofstream outFile;                                   // создание объекта для вывода 
    outFile.open("carinfo.txt");                        // ассоциирование его с файлом 
    cout << "Enter the make and model of autimobile: "; // ввод производителя и модели 
    cin.getline(automobile, 50);
    cout << "Enter the model year: ";                   // ввод года выпуска 
    cin >> year;
    cout << " enter the original asking price: ";        // ввод начальной цены 
    cin >> a_price;
    d_price = 0.913 * a_price;
             // Отображение информации на экране с помощью cout 
    cout << fixed;
    cout.precision(2);
    cout.setf(ios_base::showpoint);
    cout << "Make and model: " << automobile << endl;           // производитель и модель
    cout << "Year: " << year << endl;                           // год выпуска
    cout << " Was asking $" << a_price << endl;                 // начальная цена 
    cout << " Now asking $" << d_price << endl;                 // конечная цена 
             // Вывод той же информации с использованием outFile вместо cout 
    outFile << fixed;
    outFile.precision(2);
    outFile.setf(ios_base::showpoint);
    outFile << "Make and model: " << automobile << endl;        // производитель и модель
    outFile << "Year: " << year << endl;                        // год выпуска
    outFile << " Was asking $" << a_price << endl;              // начальная цена 
    outFile << " Now asking $" << d_price << endl;              // конечная цена 
    outFile.close();                                            // завершить работу с файлом 
    return 0;
}
/*
Замечания по программе 
После объявления объекта of stream в программе из листинга 6.15 с помощью метода open() можно ассоциировать объект с определенным файлом: 
ofstream outFile; // создание объекта для вывода 
outFile.open("carinfo.txt"); // ассоциирование его с файлом 
Когда работа с файлом завершена, соединение должно быть закрыто: outFile.close(); 
Обратите внимание, что метод close() не требует передачи имени файла. Дело в том, что outFile уже был ассоциирован с конкретным файлом. 
Если вы забудете закрыть файл, программа закроет его автоматически при нормальном завершении. 
Следует отметить, что outFile может использовать те же методы, что и cout. Он может применять не только операцию <<, но также разнообразные методы форматирования, такие как setf() и precision(). 
Эти методы влияют только на объект, который их вызывает. Например, можно указывать разные значения точности для разных объектов: 
cout.precision(2); // использовать точность 2 для вывода на экран 
outFile.precision (4); // использовать точность 4 для файлового вывода 
Главное, что вы должны помнить — после установки такого объекта ofstream, как outFile, его можно использовать точно так же, как и стандартный cout. 
Вернемся к методу open (): 
outFile.open("carinfo.txt"); 
В этом случае файл carinfo.txt перед запуском программы не существует. То есть здесь метод open () создает новый файл с таким именем. 
Но если файл carinfo.txt уже существует, что случится, если вы запустите программу вновь? 
По умолчанию open() первым делом усечет его до нулевой длины, уничтожив старое содержимое. Затем содержимое будет заменено новым выводом. 
В главе 17 описано, как можно переопределить это поведение по умолчанию. 
*/