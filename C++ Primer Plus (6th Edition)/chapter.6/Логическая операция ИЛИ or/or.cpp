/* В C++ предполагается, что операция || является точкой следования. 
Это значит, что любое изменение, проведенное в левой части, вычисляется прежде, чем  вычисляется правая часть. 
(Или, как сейчас принято в С++11, подвыражение слева от операции находится с -точки зрения последовательности перед подвыражением справа от операции.) 
Например, рассмотрим следующее выражение: 
i++ < 6 || i == j 
Предположим, что изначально переменная і имела значение 10. 
К моменту сравнения с j переменная і получает значение 11. Таким образом, C++ не заботится о правой части выражения, если выражение слева истинно, потому что одного  
истинного выражения достаточно, чтобы все составное выражение было оценено как истинное. 
(Вспомните, что операции точки с запятой и запятой также являются точками следования.) 
В листинге 6.4 используется операцию || внутри if для того, чтобы проверить заглавную и прописную версии символа. 
К тому же применяется средство конкатенации строк C++ (см. главу 4) для разнесения одной строки на три строки в коде. 
Листинг 6.4. or.срр */
// or.срр — использование логической операции "ИЛИ" 
#include <iostream>
int main(void)
{
    using namespace std;
    cout << "This program may reformat your hard disk\n"
            "and destroy all your data.\n"
            "Do you wish to continue? <y/n>";
    char ch;
    cin >> ch;
    if(ch == 'y' || ch == 'Y') // у или Y 
    cout <<"You were warned!\a\a\a";
    else if(ch == 'n' || ch == 'N') // n или N 
    cout << "A wise choice .... bye\n";
    else
    cout << "That wasn't a y or n! Apparently you "
                "can't follow\ninstructions, so "
                "I'll trash your disk anyway.\a\a\a\a";
    return 0;
}
/*
Эта программа читает только один символ, поэтому принимается во внимание только первый символ ответа. 
Это значит, что пользователь может ввести N0! вместо N, но программа прочитает только N. Но если ей пришлось бы читать еще входные символы, то первым оказался бы символ 0. 
*/