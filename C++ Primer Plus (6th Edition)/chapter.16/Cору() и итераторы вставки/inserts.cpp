/* Эти итераторы принимают тип контейнера в качестве аргумента шаблона и фактический идентификатор контейнера — как аргумент конструктора. 
Таким образом, чтобы создать итератор back_insert_iterator для контейнера vector<int> по имени dice, нужно написать следующий оператор: 
back_insert_iterator<vector<int> > back_iter(dice); 
Необходимость объявления типа контейнера обусловлена тем, что итератор должен применять соответствующий метод контейнера. 
Код конструктора back_insert_iterator будет исходить из предположения о существовании метода push_back() для переданного ему типа. 
Функция сору(), будучи автономной функцией, не обладает правами доступа для изменения размера контейнера. 
Но приведенное объявление позволяет back_iter пользоваться методом vector<int>: :push_back(), который обладает нужными правами доступа. 
Объявление front_insert_iterator имеет ту же форму. 
Объявление insert_iterator содержит дополнительный аргумент конструктора для указания позиции вставки: 
insert_iterator<vector<int>> insert_iter(dice, dice.begin()); 
Код в листинге 16.11 иллюстрирует применение этих двух итераторов. 
Кроме того, для вывода вместо итератора ostream он использует функцию for_each(). 
Листинг 16.11. inserts.срр */
// inserts.срр — сору() и итераторы вставки 
#include <iostream>
#include <string>
#include <iterator>
#include <vector>
#include <algorithm>
void output(const std::string & s) 
{
    std::cout << s << " ";
}
int main()
{
    using namespace std;
    string s1[4] = {"fine", "fish", "fashion", "fate"};
    string s2[2] = {"buse", "bats"};
    string s3[2] = {"silly", "singers"};
    vector<string> words(4);
    copy(s1, s1 + 4, words.begin());
    for_each(words.begin(), words.end(), output);
    cout << endl;
    // Конструирование анонимного объекта типа back_insert_iterator 
    copy(s2, s2 + 2, back_insert_iterator<vector<string> >(words));
    for_each(words.begin(), words.end(), output);
    cout << endl;
    // Конструирование анонимного объекта типа insert_iterator 
    copy(s3, s3 + 2, insert_iterator<vector<string> >(words, words.begin()));
    for_each(words.begin(), words.end(), output);
    cout << endl;
    return 0;
}
/*
Первый вызов copy() копирует четыре строки из si в words. 
Этот вызов работает, в частности, и потому, что массив words объявлен как содержащий четыре строки, что равно количеству копируемых строк. 
Затем back_insert_iterator вставляет строки из s2 в место, находящееся перед концом массива words, увеличивая размер words до шести элементов. 
И, наконец, insert_iterator вставляет две строки из s3 перед первым элементом words*, увеличивая его размер до восьми элементов. 
Если бы программа попыталась копировать s2 и s3 в массив words, используя функции words.end() и words.begin() в качестве итераторов, скорее всего, в массиве words 
не хватило бы места для новых данных и программа, вероятно, была бы прервана вследствие нарушений, связанных с памятью. 
Несмотря на обилие вариаций итераторов, имейте в виду, что их практическое применение поможет быстро освоиться с ними. 
Также помните, что эти заранее определенные итераторы повышают степень обобщения алгоритмов STL. Так, сору() позволяет копировать информацию не только из одного контейнера в другой, но и из 
контейнера в выходной поток и из входного потока в контейнер, сору() можно применять также для вставки данных в другой контейнер. 
Таким образом, единственная функция может выполнять работу многих других. И поскольку сору() — лишь одна из нескольких функций STL, которые используют выходной итератор, эти заранее  
определенные итераторы увеличивают возможности и этих функций. 
*/