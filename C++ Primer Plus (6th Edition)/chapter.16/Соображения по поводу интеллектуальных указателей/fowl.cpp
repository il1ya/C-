/* Зачем нужны три интеллектуальных указателя? (В действительности их четыре, но указатель weak_ptr обсуждаться не будет.) 
И почему отказались от указателя auto_ptr? 
Начнем с рассмотрения следующего присваивания: 
auto_ptr<string> ps(new string("I reigned lonely as a cloud.")); 
auto_ptr<string> vocation; 
vocation = ps; 
Каким должен быть результат этого оператора присваивания? Если бы ps и vocation были обычными указателями, результатом стали бы два указателя на один и тот же объект string. 
В данном случае это недопустимо, поскольку программа вела бы себя непредсказуемо, пытаясь удалить один объект дважды — при удалении ps и при удалении vocation. 
Существуют следующие способы предотвращения этой проблемы. 
• Определить операцию присваивания так, чтобы она создавала точную копию объекта. 
Тогда два указателя будут указывать на два разных объекта, один из которых является копией второго. 
• Использовать концепцию владения, когда определенным объектом может владеть только один интеллектуальный указатель. 
Деструктор будет удалять объект только тогда, когда интеллектуальный указатель владеет объектом. 
Затем можно использовать операцию присваивания, которая будет передавать право владения объектом. 
Эта стратегия применяется указателями autoptr и uniqueptr, но uniqueptr накладывает несколько больше ограничений. 
• Создать еще более интеллектуальный указатель, который будет отслеживать, сколько интеллектуальных указателей ссылается на определенный объект. 
Эта стратегия называется подсчетом ссылок. Например, присваивание могло бы увеличивать значение счетчика на единицу, а удаление указателя — уменьшать его. 
Тогда операция delete вызвалась бы только при удалении последнего указателя. Эта стратегия применяется для указателя sharedptr. 
Те же самые стратегии применимы и к конструкторам копирования. Каждый подход находит свое применение. 
В листинг 16.6 представлен пример, в котором указатель autoptr не особенно хорошо подходит. 
Листинг 16.6. fowl.cpp */
// fowl. срр — auto_ptr - неудачный выбор 

#include <iostream> 
#include <string> 
#include <memory> 

int main() 
{ 
    using namespace std; 
    auto_ptr<string> films[5] = 
        { 
        auto_ptr<string> (new string("Fowl Balls")), 
        auto_ptr<string> (new string("Duck Walks")), 
        auto_ptr<string> (new string("Chicken Runs")), 
        auto_ptr<string> (new string("Turkey Errors")), 
        auto_ptr<string> (new string("Goose Eggs")) 
        }; 
    auto_ptr<string> pwin; 
    pwin = films[2];    // films[2] утрачивает права владения 
    cout << "The nominees for best avian baseball film are\n"; 
    for(int i = 0; i < 5; i++) 
        cout << *films[i] << endl; 
        cout << "The winner is " << *pwin << " !\n"; 
    cin.get(); 
    return 0; 
}
/*
Сообщение "Segmentation 'fault' (core dumped)" (Ошибка сегментации (дамп ядра записан)) должно служить напоминанием о том, что неправильное использование объекта auto_ptr может привести к возникновению проблем. 
(Поведение такого кода неопределенно, поэтому можно столкнуться с различным поведением в зависимости от конкретной системы.) 
В данном случае проблема заключается в том, что следующий оператор передает права владения от films[2] к pwin: 
pwin = films[2]; // films[2] утрачивает права владения 
Это ведет к тому, что элемент массива films[2] перестает ссылаться на строку. 
После того, как auto_ptr передает права владения объектом, он больше не предоставляет доступ к этому объекту. 
Когда программа приступает к выводу строки,  указанной элементом films[2], она обнаруживает нулевой указатель, что, несомненно, оказывается неприятным сюрпризом. 
Предположим, что мы возвратились к листингу 16.6, но вместо auto_ptr использовали shared_ptr. 
(Компилятор должен поддерживать класс shared_ptr из С++11.) 
В этом случае программа выполняется успешно и дает следующий вывод: 
The nominees, for best avian baseball film are 
Fowl Balls 
Duck Walks 
Chicken Runs 
Turkey Errors 
Goose Eggs 
The winner is Chicken Runs! 
Различие состоит в следующей части программы: shared_ptr<string> pwin; 
pwin = films[2]; 
На этот раз и pwin, и films[2] указывают на один и тот же объект, а значение  счетчика ссылок увеличивается с 1 до 2. 
В конце программы объект pwin, который был объявлен последним, оказывается первым, чей деструктор будет вызван. 
Деструктор уменьшает значение счетчика ссылок до 1. 
Затем элементы массива sharedptrs освобождаются. 
Деструктор films[2] уменьшает значение счетчика до 0 и освобождает ранее выделенную память. 
Это же относится к shared_ptr. Программа из листинга 16.6 выполняется успешно. 
При использовании auto_ptr происходит ошибка времени выполнения. А что происходит в случае применения unique_ptr? 
Как и auto_ptr, uniqueptr использует модель владения. Однако вместо сбоя версия с uniqueptr генерирует ошибку во время компиляции следующей строки кода: 
pwin = films[2]; 
Очевидно, что пора подробнее рассмотреть различия между этими двумя последними типами. 
*/