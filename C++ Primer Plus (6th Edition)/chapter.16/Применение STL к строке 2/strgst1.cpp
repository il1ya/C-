/*
Иногда возникает ситуация, когда требуется произвести выбор между использованием метода STL либо функции STL. 
Обычно лучшим вариантом является метод. 
Во-первых, он должен быть лучше оптимизирован для конкретного контейнера. 
Во-вторых, будучи функцией-членом, он может пользоваться средствами управления памятью класса шаблона и при необходимости изменять размер контейнера. 
Предположим, например, что имеется список чисел, и нужно удалить из него все экземпляры определенного значения, скажем, 4. 
Если 1а — это объект list<int>, 
можно применить метод remove() списка: 
la.remove(4); // удаление всех четверок из списка 
После вызова этого метода все элементы со значением 4 удаляются из списка и размер списка автоматически изменяется. 
В STL существует также алгоритм remove() (см. приложение Ж). Вместо того чтобы вызываться объектом, он принимает аргументы, задающие диапазон. 
Поэтому, если lb — это объект list<int>, то вызов данной функции может выглядеть следующим образом: 
remove (lb.begin (), lb.endO, 4); 
Однако, поскольку функция remove() не является членом класса, она не может изменить размер списка. 
Вместо этого она удостоверяется, что все не удаленные элементы располагаются в начале списка, и возвращает итератор, указывающий на новое значение за концом списка. 
Затем этот итератор можно применять для корректировки размеров списка. 
Например, метод erase() списка можно использовать для удаления диапазона, который описывает более не нужную часть списка. 
Работа этого процесса продемонстрирована в листинге 16.18. 
Листинг 16.18. listzrav.срр */
// strgstl.cpp -- применение STL к строке 
#include <iostream>
#include <list>
#include <algorithm>

void Show(int);
const int LIM = 10;
int main()
{
    using namespace std;
    int ar[LIM] = {4, 5, 3, 2, 2, 3, 4, 8, 1, 4};
    list<int> la(ar, ar + LIM);
    list<int> lb(la);
    cout << "Original list contents:\n\t";      // вывод содержимого исходного списка 
    for_each(la.begin(), la.end(), Show);
    cout << endl;
    la.remove(4);
    cout << "After using the remove() method:\n";
            // список после использования метода remove () 
    cout << "la:\t";
    for_each(la.begin(), la.end(), Show);
    cout << endl;
    list<int>::iterator last;
    last = remove(lb.begin(), lb.end(), 4);
    cout << "After using the remove() function:\n";
            // список после использования функции remove() 
    cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
    cout << endl;
    lb.erase(last, lb.end());
    cout << "After using the erase() method:\n";
            // список после использования метода erase() 
    cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
    cout << endl;
    return 0;
}

void Show(int v)
{
    std::cout << v << ' ';
}
/*
Как видите, метод remove() уменьшает размер списка la с 10 до 6 элементов. 
Однако после вызова функции remove () список lb по-прежнему содержит 10 элементов. 
Последние четыре элемента освобождаются, потому что каждый из элементов со значением 4 либо с дублированным значением перемещен ближе к началу списка. 
Хотя обычно методы подходят лучше, обычные функции более универсальны. 
Как вы видели, их можно использовать с массивами и объектами string, равно как и с контейнерами STL. 
И их можно применять с контейнерами смешанных типов, например, для сохранения данных контейнера vector в списке или наборе. 
*/