/*
Объекты initializer_list можно применять в коде, подключая заголовочный файл initializer_list. 
Класс шаблона имеет члены begin() и end(), и их можно использовать для получения доступа к элементам списка. 
Класс имеет также член size(), который возвращает количество элементов. 
Простой пример использования initializer_list приведен в листинге 16.22. Он требует применения компилятора, который поддерживает это средство С++11. 
Листинг 16.22. list.cpp 
*/
// ilist.cpp — использование initializer_list (средство С++11) 
#include <iostream>
#include <initializer_list>

double sum(std::initializer_list<double> il);
double average(const std::initializer_list<double> &ril);

int main()
{
    using std::cout;
    cout << "List 1: sum = " << sum({2,3,4}) << ", ave = " << average({2,3,4}) << '\n'; // список 1, его сумма и среднее 
    std::initializer_list<double> dl = {1.1, 2.2, 3.3, 4.4, 5.5};
    cout << "List 2: sum = " << sum(dl) << ", ave = " << average(dl) << '\n';           // список 2, его сумма и среднее 
    dl = {16.0, 25.0, 36.0, 40.0, 64.0};
    cout << "List 3: sum = " << sum(dl) << ", ave = " << average(dl) << '\n';           // список 3, его сумма и среднее 
    return 0;
}

double sum(std::initializer_list<double> il)
{
    double tot = 0;
    for(auto p = il.begin(); p != il.end(); p++)
        tot += *p;
        return tot;
}

double average(const std::initializer_list<double> &ril)
{
    double tot = 0;
    int n = ril.size();
    double ave = 0.0;
    if(n > 0)
    {
        for(auto p = ril.begin(); p != ril.end(); p++)
            tot += *p;
            ave = tot / n;
    }
    return ave;
}
/*
Замечания по программе 
Объект initializer_list можно передавать по значению или по ссылке, как продемонстрировано в функциях sum() и average(). 
Сам по себе объект мал и, как правило, состоит из двух указателей (одного на начало, и второго — на элемент, следующий за последним) или указателя на начало и целочисленного значения,  
представляющего размер, поэтому выбор конкретного способа не имеет особого значения для производительности. (В STL они передаются по значению.) 
Аргументом функции может быть литерал списка, подобный {2,3,4} или переменная списка вроде dl. 
Типом итераторов для initializer_list является const, поэтому изменение значений в списке невозможно: 
*dl.begin() = 2011.6; // не разрешено 
Но, как показано в листинге 16.22, переменную списка можно присоединить к другому списку: 
dl = {16.0, 25.0, 36.0, 40.0, 64.0}; // разрешено 
Однако запланированное применение класса initializer_list — передача списка значений конструктору или другой функции. 
*/