/* Обратные указатели должны выполнять специальную компенсацию. Предположим, что rp — обратный указатель, инициализированный в dice.rbegin(). 
Каким должно быть значение *rp? Поскольку rbegin() возвращает элемент, находящийся за последним в контейнере, не нужно пытаться разыменовывать этот адрес. 
Аналогично, если rend() — действительное местоположение первого элемента, сору() останавливается за один элемент до первого элемента контейнера, поскольку диапазон не включает в себя последний элемент. 
Обратные указатели решают обе проблемы, вначале выполняя декремент, а затем разыменование. То есть *гр разыменовывает значение 
итератора, непосредственно предшествующее текущему значению * гр. Если гр указывает на шестую позицию в контейнере, то *гр — значение из пятой позиции, и т.д. 
Применение функции сору(), итератора ostream и обратного итератора иллюстрируется в листинге 16.10. 
Листинг 16.10.copyit.cpp */
// copyit.cpp — copy () и итераторы 
#include <iostream>
#include <iterator>
#include <vector>
int main()
{
    using namespace std;
    int casts[10] = {6, 7, 2, 9, 4, 11, 8, 7, 10, 5};
    vector<int> dice(10);

    // Копирование из массива в вектор 
    copy(casts, casts + 10, dice.begin());
    cout << "Let the dice be cast!\n";

    // Создание итератора ostream 
    ostream_iterator<int, char> out_iter(cout, " ");

    // Копирование из вектора в выходной поток 
    copy(dice.begin(), dice.end(), out_iter);
    cout << endl;
    cout << "Implicit use of reverse iterator.\n";

    // неявное использование обратного итератора 
    copy(dice.rbegin(), dice.rend(), out_iter);
    cout << endl;
    cout << "Explicit use of reverse iterator.\n";
    
    // явное использование обратного итератора 
    vector<int>::reverse_iterator ri;
    for(ri = dice.rbegin(); ri != dice.rend(); ++ri)
        cout << *ri << ' ';
        cout << endl;
    return 0;
}
/*
Когда есть возможность выбора между явным объявлением итераторов и использованием функций STL для выполнения всей работы внутренним образом, например, 
посредством передачи возвращаемого значения rbegin() функции, следует отдавать предпочтение второму подходу. 
В этом случае придется делать меньше работы и будет меньше шансов допустить ошибку. 
Другие три итератора (back_insert_iterator, front_insert_iterator и insert_iterator) также повышают степень обобщенности алгоритмов STL. 
Многие функции STL подобны сору() в том, что передают свои результаты по адресу, указанному выходным итератором. 
Вспомните, что следующий оператор копирует значения в позицию, начинающуюся с dice.begin(): copy(casts/ casts + 10, dice.begin()); 
Эти значения замещают предыдущее содержимое dice, и функция предполагает, что dice имеет достаточно места, чтобы уместить все значения. 
Это значит, что сору() не предпринимает автоматическое изменение размеров контейнера назначения, чтобы вместить переданную в него информацию. 
Программа в листинге 16.10 заботится об этом, объявляя dice с 10 элементами, но предположим, что требуемый размер dice заранее не известен. 
Или представим, что требуется добавлять элементы в dice, а не замещать существующие. 
Эти проблемы решают три итератора вставки, преобразуя процесс копирования в процесс вставки. 
Вставка добавляет новые элементы, не перезаписывая существующие данные, и при этом использует автоматическое выделение памяти для обеспечения того, что новая информация поместится в контейнере. 
Итератор back_insert_iterator вставляет элементы в конец контейнера, а front_insert_iterator — в его начало. 
И, наконец, insert_iterator вставляет элементы перед позицией, указанной в аргументе конструктора insert_iterator. 
Все эти три итератора являются моделями концепции выходного контейнера. 
Однако существуют некоторые ограничения. Так, например, back_insert_iterator может применяться только с контейнерными типами, которые допускают быструю вставку в конец. 
(Термин быстрая относится к алгоритму с постоянным временем; понятие постоянного времени рассматривается в разделе "Концепции контейнеров" далее в главе.) Класс vector позволяет это делать. 
*/