/* Библиотека string поддерживает множество других возможностей для работы со строками.
Среди этих возможностей, например, удаление части или всей строки, замена части или всей строки частью другой строки (или всей строкой), добавление 
и удаление данных из строки, сравнение частей строк и строк целиком, извлечение подстроки из строки, копирование одной строки в другую, 
обмен содержимым двух строк. 
Большинство этих функций перегружено и может работать как со строками в стиле С, так и с объектами string. 
Функции библиотеки string кратко описаны в приложении Е, но несколько функций мы рассмотрим в этой главе. 
Первым делом обратимся к возможности автоматического изменения размера строки. 
Что происходит, когда программа из листинга 16.3 дописывает букву в конец строки? 
Она не может просто увеличить размер строки, поскольку это может привести к использованию соседних областей памяти, которые уже заняты. 
Поэтому нужно выделить новый блок памяти и скопировать туда старое содержимое строки. 
Частое повторение такой процедуры приводило бы к снижению производительности,  
поэтому большинство реализаций C++ выделяют для строки блок памяти больший, чем фактическая строка, обеспечивая возможность ее увеличения. 
Когда со временем размер строки превышает размер этого блока, программа выделяет новый блок, вдвое больше 
текущего, обеспечивая дополнительное свободное место без постоянного изменения размера. 
Метод capacity() возвращает размер текущего блока, а метод reserve() позволяет запросить минимальный размер для блока. 
Пример использования этих методов приведен в листинге 16.4. 
Листинг 16.4. str2.cpp */
// str2.cpp -- использование методов capacity() и reserve() 
#include <iostream>
#include <string>
int main()
{
    using namespace std;
    string empty;
    string small = "bit";
    string larger = "Elephants are a girl's best friend";
    cout << "Sizes:\n";
    cout << "\tempty: " << empty.size() << endl;
    cout << "\tsmall: " << small.size() << endl;
    cout << "\tlarger: " << larger.size() << endl;
    cout << "Capacities:\n";
    cout << "\tempty: " << empty.capacity() << endl;
    cout << "\tsmall: " << small.capacity() << endl;
    cout << "\tlarger: " << larger.capacity() << endl;
    empty.reserve(50);
    cout << "Capacity after empty.reserve(50): " << empty.capacity() << endl;
    return 0;
}
/*
Обратите внимание, что в этой реализации для строки резервируется минимум 15 символов и, похоже, что стандартный шаг увеличения размера на единицу меньше 
значений, кратных 16. 
В других реализациях языка значения могут быть иными. 
Но как поступить, если имеется объект string, а нужна строка в стиле С?  
Например, может требоваться открыть файл, имя которого хранится в объекте string: 
string filename; 
cout << "Enter file name: "; 
cin >> filename; 
ofstream fout; 
Проблема в том, что метод open() требует в качестве аргумента строку в стиле С. 
Однако существует метод c_str(), который возвращает указатель на строку в стиле С с тем же содержимым, что и у вызывающего объекта string. 
Поэтому можно использовать следующий оператор: 
fout.open(filename.c_str()); 
*/