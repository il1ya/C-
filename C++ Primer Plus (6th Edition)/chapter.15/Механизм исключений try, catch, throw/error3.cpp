/*
Механизм исключений 
А теперь посмотрим, как позволяет справляться с проблемами механизм исключений. 
В языке C++ исключение — это реакция на нештатную ситуацию, возникшую во время выполнения программы, например, при делении на ноль. 
Исключения позволяют передать управление из одной части программы в другую. 
Для управления исключениями доступны три компонента: 

• генерация исключения; 
• перехват исключения обработчиком; 
• использование блока try. 

Программа генерирует исключение, когда возникает проблемная ситуация. 
Например, можно изменить функцию hmean() из листинга 15.7, чтобы она генерировала исключение вместо вызова функции abort(). 
В сущности, оператор throw является оператором перехода, поскольку при этом управление передается операторам в другом месте программы. 
Ключевое слово throw является признаком генерации исключения. 
После него указывается значение — например, символьная строка или объект, — обозначающее природу исключения. 
Программа перехватывает исключение с помощью обработчика исключений, расположенного в том месте программы, где исключение необходимо обработать. 
Ключевое слово catch означает перехват исключения. 
Обработчик исключения начинается с ключевого слова catch, за которым следует объявление типа (в круглых скобках), представляющее тип исключения, которому оно соответствует. 
За ними в фигурных скобках располагается блок кода, выполняющего необходимые действия. 
Ключевое слово catch вместе с типом исключения играет роль метки, определяющей точку в программе, куда должно быть передано управление при возникновении исключения. 
Обработчик исключения называется также блоком catch или блоком перехвата. 
Блок try представляет собой блок кода, в котором активизируются определенные исключения. 
За ним следуют один или несколько блоков catch. Блок try начинается с ключевого слова try, а за ним в фигурных скобках находится код, в котором отслеживаются исключения. 
Проще всего продемонстрировать взаимодействие этих трех элементов на коротком примере, приведенном в листинге 15.9. 
Листинг 15.9. еггогЗ.срр 
*/
// еггогЗ.срр — использование исключения 

#include <iostream>

double hmean(double a, double b);

int main()
{
    double x, y, z;
    std::cout << "Enter two numbers: ";     // запрос на ввод двух чисел 
    while(std::cin >> x >> y)
    {
        try                                 // начало блока try 
        {
            z = hmean(x, y);
        }                                   // конец блока try 
        catch(const char *s)                // начало обработчика исключений 
        {
            std::cout << s << std::endl;
            std::cout << "Enter a new pair of numbers: "; // запрос на ввод новой пары чисел 
            continue;
        }                                   // конец обработчика исключений 
        std::cout << "Harmonic mean of " << x << " and " << y << " is " << z << std::endl;  // вывод среднего гармонического 
        std::cout << "Enter next set of numbers <q to quit>: "; // запрос следующих двух чисел 
    }
    std::cout << "Bye!\n";
    return 0;
}
double hmean(double a, double b)
{
    if(a == -b)
        throw "bad hmean() arguments: a = -b not allowed";
        return 2.0 * a * b / (a + b);
}
/*
Замечания по программе 
Блок try в листинге 15.9 выглядит следующим образом: 
 try                                        // начало блока try 
        {
            z = hmean(x, y);
        }                                   // конец блока try 

Если какой-то оператор в этом блоке приведет к генерации исключения, то обработка исключения произойдет в блоках catch, следующих за этим блоком try. 
Если программа вызовет hmean() где-нибудь вне этого (или любого другого) блока try, она не сможет обработать исключение. 
Генерация исключения выглядит так:

    if(a == -b)
        throw "bad hmean() arguments: a = -b not allowed";

В данном случае генерируемое исключение представляет собой строку throw "bad hmean() arguments: a = -b not allowed";. 
Исключение может иметь строковый тип, как в данном примере, или любой другой тип C++. Обычно исключение имеет тип класса, как будет показано ниже в этой главе. 
Выполнение оператора throw слегка похоже на выполнение оператора возврата в функции — в том смысле, что он завершает выполнение функции. 
Однако вместо возврата управления вызывающей программе оператор throw заставляет программу возвращаться по текущей цепочке вызовов функций до тех пор, пока не будет найден блок try. 
В листинге 15.9 такой функцией является вызывающая функция. Ниже мы рассмотрим пример с возвратом более чем на один уровень. 
В данном случае оператор throw передает управление обратно в main(). 
Здесь программа ищет обработчик исключения (следующий за блоком try), который соответствует типу сгенерированного исключения. 
Обработчик, или блок catch, выглядит следующим образом:

catch(const char *s)                        // начало обработчика исключений 
        {
            std::cout << s << std::endl;
            std::cout << "Enter a new pair of numbers: "; // запрос на ввод новой пары чисел 
            continue;
        }                                   // конец обработчика исключений 

Блок catch немного похож на определение функции, но это не функция. Ключевое слово catch указывает, что это обработчик, а выражение char *s означает, что обработчик соответствует строковым исключениям. 
Такое объявление s аналогично определению аргумента функции, и если возникшее исключение соответствует этому объявлению, оно присваивается s, а затем программа выполняет код внутри фигурных скобок. 
Если программа выполнила все операторы внутри блока try без возникновения исключений, она пропускает все блоки catch и переходит к выполнению операторов, следующих за обработчиками исключений. 
Поэтому когда программа из листинга 15.9  обработает значения 3 и б, она переходит сразу к оператору вывода и выводит результат. 
Давайте проследим, что происходит в примере, после того как значения 10 и -10 будут обработаны функцией hmean(). 
Проверка if заставляет hmean() сгенерировать исключение. 
Выполнение hmean() прекращается. Просматривая стек вызовов,  программа определяет, что функция hmean() была вызвана внутри блока try в main(). 
Затем программа ищет блок catch с типом, который соответствует типу исключения. 
Единственный существующий блок catch имеет параметр char *, поэтому он соответствует исключению. 
Найдя соответствие, программа присваивает переменной s значение 

"bad hmean() arguments: a = -b not allowed". 

Затем программа выполняет код обработчика. Сначала выводится строка s с описанием исключения. После этого программа предлагает ввести новые данные. 
И, наконец, выполняется оператор continue, который пропускает остаток тела цикла while и передает управление его началу. 
То, что оператор continue переносит управление в начало цикла, говорит о том, что обработчик является частью цикла, и что строка catch ведет себя как метка, направляющая поток выполнения программы (рис. 15.2). 
А что произойдет, если функция сгенерирует исключение, но нет ни одного блока try или соответствующего обработчика? 
По умолчанию программа вызовет функцию abort(), однако такое поведение можно изменить. Мы вернемся к этой теме далее в главе. 
*/