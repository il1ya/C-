/*
Пусть опять High и Low — два класса, и рассмотрим следующий код: 
High bar; 
    const High * pbar = &bar; 
    High * pb = const_cast<High *> (pbar);             // верно 
    const Low * pi = const_cast<const Low *> (pbar);   // неверно 
Первое приведение типа делает *pb указателем, который можно использовать для изменения значения объекта bar; оно удаляет метку const. 
Второе приведение неверно, поскольку оно пытается изменить тип с const High * на const Low *. 
Эта операция предназначена для того случая, когда нужно иметь величину, которая большую часть времени постоянна, но иногда все же может изменяться. 
В этом случае ее можно объявить как const и использовать операцию const_cast, если потребуется изменить ее значение. 
Это можно сделать с помощью обычного приведения типа, но тогда изменится и тип: 
    High bar; 
    const High *pbar = &bar; 
    High *pb = (High *) (pbar);    // верно 
    Low *pi = (Low *) (pbar);      // тоже верно 
Поскольку одновременное изменение типа и постоянства значения может оказаться непреднамеренной программной ошибкой, безопаснее применять операцию 
const_cast. 
Операция constcast не во всем хороша. Она может изменить указатель на величину, но эффект попытки изменения значения, объявленного с квалификатором const, не определен. 
Для наглядности рассмотрим короткий пример, приведенный в листинге 15.19. 
Листинг 15.19. constcast.cpp */
// constcast.cpp -- использование const_cast<> 
#include <iostream>
using std::cout;
using std::endl;
void change(const int *pt, int n);
int main()
{
    int pop1 = 38383;
    const int pop2 = 2000;
    cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;
    change(&pop1, -103);
    change(&pop2, -103);
    cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;
    return 0;
}
void change(const int *pt, int n)
{
    int *pc;
    pc = const_cast<int *>(pt);
    *pc += n;
}

/*
Операция const_cast может удалить квалификатор const из const int *pt, что позволяет компилятору в функции change() воспринять следующий оператор: 

    *рс += п; 

Но поскольку переменная рор2 объявлена как const, компилятор может защитить ее от изменений, как показано в следующем примере выходных данных программы: 

    popl, pop2: 38383, 2000 
    popl, pop2: 38280, 2000 

Как видите, вызов change() изменяет значение popl, но не рор2. Указатель в функции change() объявлен как const int *, поэтому его нельзя использовать для 
изменения целого числа, на которое он указывает. 
Указатель рс отбрасывает приведение const, и он позволяет изменить значение, на которое указывает, но только если само значение не объявлено как const. 
Поэтому рс можно использовать для изменения popl, но не рор2. 
Операция static_cast имеет такой же синтаксис, как и другие операции: 

    static_cast <имя-типа> (выражение) 

Она допустима только в том случае, если имя-типа может быть неявно преобразовано в тип, который имеет выражение, или наоборот. 
В любом другом случае такое приведение считается ошибочным. Пусть High — базовый класс для Low, a Pond — несвязанный класс. 
Тогда приведение High к Low и обратно допустимо, а приведение Low к Pond — нет: 
    High bar; 
    Low blow; 
    High * pb = static_cast<High *> (&blow);    // допустимое восходящее приведение 
    Low * pi = static_cast<Low *> (&bar);       // допустимое нисходящее приведение 
    Pond * pmer = static_cast<Pond *> (&blow);  // не допускается, Pond не входит в иерархию

Первое преобразование является допустимым, поскольку восходящее приведение может быть выполнено явно. 
Второе преобразование — из указателя на базовый класс в указатель на производный класс — не может быть выполнено без явного приведения типа. 
Но поскольку обратное преобразование возможно без приведения типа,  операцию static_cast можно использовать для нисходящего преобразования. 
Аналогично, значение перечисления может быть преобразовано в целый тин без приведения,- и поэтому целочисленный тип можно преобразовать в значение перечисления с помощью операции static_cast. 
Кроме того, static_cast позволяет преобразовать double в int, float в long и выполнять многие другие числовые преобразования. 
Операция reinterpret_cast предназначена для рискованных приведений типов. 
Она не позволит отбросить квалификатор const, но может вызвать другие неприятные вещи. 
Иногда программистам приходится писать зависящий от реализации код, и применение reinterpret_cast упрощает такой процесс. 
Эта операция имеет такой же синтаксис, что и остальные три операции: 

    reinterpret_cast <имя-типа> {выражение) 

Ниже показан пример ее использования:

    struct dat {short a; short b;}; 
    long value = 0xA224B118; 
    dat *pd = reinterpret_cast<dat *> (&value); 
    cout << hex << pd->a;        // вывод первых двух байтов значения 

Обычно такое приведение типа применяется при низкоуровневом, зависящем от реализации программировании, и полученный код не всегда возможно перенести в другую систему: 
эта система может хранить байты не в том формате или в другом порядке. 
Однако операция reinterpret_cast не позволяет делать вообще все что угодно. 
Например, можно привести тип указателя к целочисленному типу, который достаточно велик, чтобы хранить указатель, но нельзя привести указатель к меньшему целому типу или к типу с плавающей точкой. 
Существует еще одно ограничение: нельзя привести указатель на функцию к указателю на данные и наоборот. 
Обычное приведение типов в C++ также ограничено. 
В основном оно может делать то же, что и другие приведения, плюс сочетания вроде static_cast или reinterpret_cast, за которыми следует const cast. 
Но это, пожалуй, и все. Так что следующее приведение допустимо в С, но обычно запрещено в C++, потому что в большинстве реализаций C++ тип char слишком мал, чтобы содержать указатель: 
    char ch = char (&d);        // приведение типа #2 — преобразование адреса в символ 
Такие меры предосторожности имеют смысл, но если вы считаете их излишними — к вашим услугам язык С. 
*/