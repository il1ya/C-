/* А теперь взглянем, как и было обещано, на пример, использующий peek() для определения того, была ли считана вся строка целиком (см. листинг 17.15). 
Если во входном массиве умещается только часть строки, программа отбрасывает остальную ее часть. 
Листинг 17.15. truncate.срр */
// truncate.срр — использование get() для усечения входной строки в случае необходимости 
#include <iostream>
const int SLEN = 10;
inline void eatline() 
{ 
    while(std::cin.get() != '\n')
    continue;
}
int main()
{
    using std::cin;
    using std::cout;
    using std::endl;

    char name[SLEN];
    char title[SLEN];
    cout << "Enter your name: ";                                            // приглашение для ввода имени 
    cin.get(name, SLEN);
    if(cin.peek() != '\n')
        cout << "Sorry, we only have enough room for " << name << endl;     // вывод сообщения о недостатке места 
    eatline();
    cout << "Dear " << name << ", enter your tutle: \n";                    //приглашение для ввода должности 
    cin.get(title, SLEN);
    if(cin.peek() != '\n')
        cout << "We were forced to truncate your title.\n";
                // вынужденное усечение названия должности 
    eatline();
    cout << " Name: " << name << "\nTitle: " << title << endl;

    return 0;
}

/* Обратите внимание, что следующий код имеет разный смысл в зависимости от того, считывает ли первый оператор ввода полную строку: 
{ 
    while(std::cin.get() != '\n')
    continue;
}
Если get() считывает полную строку, он все же оставляет на месте символ перевода строки, и этот код читает и отбрасывает символ новой строки. 
Если же get() считывает только часть строки, этот код читает и отбрасывает остаток строки. 
Если бы остаток строки не был отброшен, следующий оператор ввода начал бы считывание с начала оставшейся части первой строки ввода. 
В данном примере это привело бы к чтению строки sniffer в массив title. 
*/