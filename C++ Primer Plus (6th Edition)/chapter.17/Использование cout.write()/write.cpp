/* 
Некоторые компиляторы ошибочно перегружают put() для трех типов аргументов: char, unsigned char и signed char. 
Это приводит к неоднозначности при вызове put() с аргументом типа int, поскольку int может быть преобразован в любой из этих трех типов. 
Метод write() записывает целую строку и имеет следующий шаблонный прототип: 
basic_ostream<charT,traits>& write(const char_type* s, streamsize n); 
Первый аргумент write() представляет адрес строки, которую нужно отобразить, а второй аргумент указывает количество отображаемых символов. 
Использование cout для вызова write() вызывает специализацию char, поэтому возвращаемым типом будет ostream &. 
В листинге 17.1 показано, как работает метод write(). 
Листинг 17.1. write.срр 
*/
// write.срр — использование cout.write() 
#include <iostream>
#include <cstring>  // или иначе string.h 

int main()
{
    using std::cout;
    using std::endl;
    const char *state1 = "Florida";
    const char *state2 = "Kansas";
    const char *state3 = "Euphoria";
    int len = std::strlen(state2);
    cout << "Increasing loop index:\n";
    int i;
    for(i = 1; i <= len; i++)
    {
        cout.write(state2, i);
        cout << endl;
    }
    // Конкатенация вывода 
    cout << "Decreasing loop index:\n";
    for(i = len; i > 0; i--)
        cout.write(state2, i) << endl;

    // Превышение длины строки 
    cout << "Exceeding string length:\n";
    cout.write(state2, len + 5) << endl;
    
    return 0;
}
/*
Некоторые компиляторы могут обнаружить, что программа объявляет, но не использует массивы statel и state3. 
Все в порядке, поскольку эти два массива служат лишь для представления данных, находящихся в памяти перед и после массивом 
state2, чтобы можно было выяснить, что происходит в случае ошибки доступа к state2. 
Обратите внимание, что вызов cout.write() возвращает объект cout. 
Это обусловлено тем, что метод write() возвращает ссылку на объект, который его вызвал, и в данном случае это — объект cout.
Это позволяет выполнять конкатенацию вывода, поскольку cout .write() замещается возвращаемым значением — объектом cout: 
cout.write(state2,i) << endl; 
Вдобавок метод write() не прекращает вывод строки по достижении нулевого ограничивающего символа. 
Он просто выводит указанное количество символов, даже если при этом выходит за пределы конкретной строки! 
В данном случае программа объединяет строку "Kansas" с двумя другими стоками, как если бы соседние области памяти содержали единый элемент данных. 
Компиляторы могут по-разному размещать данные в памяти и по-разному выравнивать ее содержимое. Например, "Kansas" 
занимает 6 байтов, но, судя по всему, данный конкретный компилятор выравнивает строки, используя значения кратные 4 байтам, поэтому "Kansas" дополняется до 
8 байт. Некоторые компиляторы разместят "Florida" после "Kansas". Поэтому из- за различий в компиляторах последняя строка вывода может выглядеть по-разному 

Однако write() обеспечивает компактный, аккуратный способ сохранения числовых данных в файле. Мы вернемся к этой возможности позднее в настоящей главе. 
*/