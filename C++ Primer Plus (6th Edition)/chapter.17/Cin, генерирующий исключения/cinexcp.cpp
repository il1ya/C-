/*
Предположим, что функция ввода установила eof bit. Приведет ли это к генерации исключения? 
По умолчанию нет. Однако для управления тем, как будут обрабатываться исключения, можно использовать метод exceptions(). 
Сначала приведем некоторые основополагающие сведения. Метод exceptions() возвращает битовое поле с тремя битами, соответствующими eofbit, failbit и badbit. 
Изменение состояния потока ведет к применению либо метода clear(), либо метода setstateO, который использует clear(). 
После изменения состояния потока метод clear() сравнивает его текущее состояние со значением, возвращенным exceptions(). 
Если бит установлен в возвращаемом значении, и соответствующий бит установлен также в текущем состоянии, то clear() генерирует исключение ios_base::failure. 
Это может случиться, например, если оба значения имеют установленный бит badbit. Отсюда следует, что если exceptions() возвращает goodbit, то исключение не генерируется. 
Класс ios_base::failure унаследован от класса std::exception, а потому имеет метод what(). 
Установкой по умолчанию для exceptions() является goodbit — т.е. никакие исключения не генерируются. 
Однако перегруженная функция exceptions (iostate) позволяет управлять этим поведением: 
cin.exceptions(badbit); // установка badbit ведет к генерации исключения 
Как описано в приложении Д, битовая операция "ИЛИ" (|) позволяет указывать более одного бита. 
Например, следующий оператор вызывает генерацию исключения при последующей установке badbit или eofbit: 
cin.exceptions(badbit | eofbit); 
В листинге 17.12 приведен модифицированный код из листинга 17.11, который генерирует и перехватывает исключение при установке бита failbit. 
Листинг 17.12. сіпехср.срр */
// cinexcp.cpp -- cin, генерирующий исключения 
#include <iostream>
#include <exception>

int main()
{
    using namespace std;
    // Установленный бит failbit вызовет генерацию исключения 
    cin.exceptions(ios_base::failbit);
    cout << "Enter numbers: ";                               // запрос на ввод чисел 
    int sum = 0;
    int input;
    try {
        while(cin >> input)
        {
            sum += input;
        }
    }catch(ios_base::failure &bf)
    {
        cout << bf.what() << endl;
        cout << "O! the horror!\n";
    }
    cout << "Last value entered = " << input << endl;       // вывод последнего введенного числа 
    cout << "Sum = " << sum << endl;                        // вывод суммы введенных чисел 
    return 0;
}
/*
Подобным образом можно использовать исключения при вводе. Но должны ли вы их использовать? Это зависит от контекста. 
Для данного примера ответ будет отрицательным. Исключения должны перехватывать необычные, непредвиденные  
ситуации, но в этой конкретной программе несоответствие типов применяется в качестве способа выхода из цикла. 
Однако в этой программе было бы целесообразно генерировать исключение для установленного бита badbit, поскольку такая ситуация была бы непредусмотренной. 
Или же, если бы программа была предназначена для чтения данных из файла вплоть до его конца, тогда, возможно, имело бы смысл генерировать 
исключение для установленного бита failbit, поскольку он свидетельствовал бы о наличии проблемы с файлом данных. 
*/