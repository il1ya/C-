/* Как работать с динамическим массивом после его создания? Для начала подумаем о проблеме концептуально. 
Следующий оператор создает указатель psome, который указывает на первый элемент блока из 10 значений int: 
int * psome = new int [10]; // получить блок для 10 элементов типа int 
Представьте его как палец, указывающий на первый элемент. Предположим, что int занимает 4 байта. Перемещая палец на 4 байта в правильном направлении, вы можете указать на второй элемент. 
Всего имеется 10 элементов, что является допустимым диапазоном, в пределах которого можно передвигать палец. 
Таким образом, операция new снабжает всей необходимой информацией для идентификации каждого элемента в блоке. 
Теперь взглянем на проблему практически. Как можно получить доступ к этим элементам? С первым элементом проблем нет. 
Поскольку psome указывает на первый элемент массива, то * psome и есть значение первого элемента. Но остается еще девять элементов. 
Простейший способ доступа к этим элементам может стать сюрпризом для вас, если вы не работали с языком С; просто используйте указатель, как если бы он был именем массива. 
То есть можно писать psome [0] вместо *psome для первого элемента, psome [1] — для второго и т.д. Получается, что применять указатель 
для доступа к динамическому массиву очень просто, хотя не вполне понятно, почему этот метод работает. 
Причина в том, что С и C++ внутренне все равно работают с массивами через указатели. Подобная эквивалентность указателей и массивов — одно из замечательных свойств С и C++. 
(Иногда это также и проблема, но это уже другая история.) Ниже об этом речь пойдет более подробно. 
В листинге 4.18 показано, как использовать new для создания динамического массива и доступа к его элементам с применением нотации обычного массива. 
В нем также отмечается фундаментальное отличие между указателем и реальным именем массива. 
Листинг 4.18. arraynew.cрр */
// arraynew.cрр -- использование операции new для массивов 
#include <iostream>
int main(void)
{
    using namespace std;
    double *p3 = new double[3];  // пространство для З значений double 
    p3[0] = 0.2;  // трактовать рЗ как имя массива 
    p3[1] = 0.5;
    p3[2] = 0.8;

    cout << "p3[1] is " << p3[1] << ".\n";       // вывод рЗ[1] 
    p3 = p3 + 1;                                 // увеличение указателя  // допускается для указателей, но не для имен массивов 
    cout << "Now p3[0] is " << p3[0] << " and "; // вывод рЗ[0] 
    cout << "p3[1] is " << p3[1] << ".\n";       // вывод рЗ[1] 
    p3 = p3 - 1;                                 // возврат указателя в начало 
    delete [] p3;                                // освобождение памяти 
    return 0;
}

/* Как видите, arraynew.cрр использует указатель рЗ, как если бы он был именем массива: рЗ[0] для первого элемента и т.д. Фундаментальное отличие между именем массива и указателем проявляется в следующей строке: 
рЗ = рЗ + 1; // допускается для указателей, но не для имен массивов 
Вы не можете изменить значение для имени массива. Но указатель — переменная, а потому ее значение можно изменить. Обратите внимание на эффект от добавления 1 к рЗ. 
Теперь выражение рЗ[0] ссылается на бывший второй элемент массива. 
То есть добавление 1 к рЗ заставляет рЗ указывать на второй элемент вместо первого. 
Вычитание 1 из значения указателя возвращает его назад, в исходное значение, поэтому программа может применить delete[] с корректным адресом. 
Действительные адреса соседних элементов int отличаются на 2 или 4 байта, 
поэтому тот факт, что добавление 1 к рЗ дает адрес следующего элемента, говорит о том, что арифметика указателей устроена специальным образом. 
Так оно и есть на самом деле. */
 
