/* Листинг 5.20 демонстрирует в одной программе инициализацию двумерного массива и проход по его элементам во вложенном цикле. 
На этот раз порядок циклов в программе изменен на противоположный, с помещением прохода по столбцам (индекс города) во внешний цикл, а прохода по строкам (индекс года) — во внутренний цикл. 
К тому же здесь используется общепринятая в C++ практика инициализации массива указателей набором строковых констант. То есть cities объявлен как массив указателей на char. 
Это делает каждый его элемент, такой как cities [0], указателем на char, который может быть инициализирован адресом строки. 
Программа инициализирует cities [0] адресом строки "Gribble City" и т.д. Таким образом, массив указателей ведет себя как массив строк. 
Листинг 5.20. nested.срр */
// nested.срр -- вложенные циклы и двумерный массив 
#include <iostream>
const int Cities = 5;
const int Years = 4;
int main(void)
{
    using namespace std;
    const char *cities[Cities] = // массив указателей на 5 строк 
    {
        "Gribble City",
        "Gribbletown",
        "New Gribble",
        "San Gribble",
        "Gribble Vista"
    };
    int maxtemps[Years][Cities] = // двумерный массив 
    {
        {96, 100, 87, 101, 105}, // значения для maxtemps [0] 
        {96, 98, 91, 107, 104},  // значения для maxtemps [1] 
        {97, 101, 93, 108, 107}, // значения для maxtemps [2] 
        {98, 103, 95, 109, 108}  // значения для maxtemps [3] 
    };
    cout << "Maximum temperatures for 2008 - 2011\n\n";
    // Максимальные температуры в 2008-2011 гг. 
    for(int city = 0; city < Cities; ++city)
    {
        cout << cities[city] << ":\t";
        for(int year = 0; year < Years; ++year)
        cout << maxtemps[year][city] << "\t";
        cout << endl;
    }
    // cin.get (); 
    return 0;
}
/*
Применение знаков табуляции позволяет разместить данные более равномерно, чем с помощью пробелов. Однако разные установки позиций табуляции могут  
привести к тому, что в различных системах вывод будет выглядеть немного по-разному. 
В главе 17 будут представлены более точные, но и более сложные методы форматирования вывода. 
В грубом варианте можно было бы использовать массив массивов char вместо массива указателей для строковых данных. Объявление выглядело бы следующим образом: 
char cities [Cities] [25] = // массив из 5 массивов по 25 символов 
{ 
    "Gribble City", 
    "Gribbletown", 
    "New Gribble", 
    "San Gribble", 
    "Gribble Vista" 
}; 
При таком подходе длина каждой из 5 строк ограничивается максимум 24 символами. 
Массив указателей сохраняет адреса пяти строковых литералов, но массив массивов char копирует каждый из пяти строковых литералов в соответствующий массив из 25 символов. 
Это значит, что массив указателей более экономичен в отношении используемой памяти. Однако если вы намерены модифицировать любую из этих пяти строк, 
то в этом случае двумерный массив символов будет более удачным вариантом. 
Это довольно странно, но оба варианта используют одинаковый список инициализации и один и тот же код циклов for для отображения строк. 
К тому же вы можете использовать массив объектов класса string вместо массива указателей для сохранения данных. Объявление будет выглядеть следующим образом: 
const string cities [Cities] = // массив из 5 строк 
{ 
    "Gribble City", 
    "Gribbletown", 
    "New Gribble", 
    "San Gribble", 
    "Gribble Vista" 
}; 
Если вам нужны модифицируемые строки, можете опустить квалификатор const. 
Эта форма будет использовать тот же список инициализации и тот же цикл for для отображения строк, как и две другие формы. Если строки будут модифицируемыми, 
то свойство автоматического изменения размера класса string делает такой подход более удобным, чем применение двумерного массива символов. 
*/