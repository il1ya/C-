/* Если программа собирается использовать цикл для чтения текстового ввода с клавиатуры, она должна каким-то образом узнать, когда следует остановиться. 
Как программа узнает об этом? Один из способов заключается в использовании некоторого специального символа, иногда называемого сигнальным символом в качестве сигнала останова. 
Например, листинг 5.16 прекращает чтение ввода, когда программа встречает символ #. Программа подсчитывает количество прочитанных символов и отображает их, т.е. повторно выводит прочитанные символы. 
(Нажатие клавиши на клавиатуре не приводит к автоматическому помещению соответствующего символа на экран; программы должны самостоятельно выполнять всю нудную работу по отображению введенного символа. 
Обычно эту задачу обрабатывает операционная система. В данном случае отображать введенные символы будет как операционная система, так и тестовая программа.) 
По завершении работы программа выдаст отчет об общем количестве обработанных символов. Исходный код этой программы приведен в листинге 5.16. 
Листинг 5.16. textinl.cpp */
// textinl.cpp — чтение символов в цикле while 
#include <iostream>
int main(void)
{
    using namespace std;
    char ch;
    int count = 0; // использование базового ввода 
    cout << "Enter characters; enter # to quit:\n";
    cin >> ch; // получение символа 
    while(ch != '#') // проверка символа 
    {
        cout << ch; // отображение символа 
        ++count; // подсчет символа 
        cin >> ch; // получение следующего символа 
    }
    cout << endl << count << " characters read\n";
    return 0;
}
/* Замечания по программе 
Обратите внимание на структуру программы в листинге 5.16. Программа читает первый введенный символ до входа в цикл. 
Таким образом, первый символ может быть проверен, когда программа достигает оператора цикла. Это важно, потому что первым символом может сразу оказаться #. 
Поскольку textinl. cpp использует цикл с проверкой на входе, в этом случае программа корректно пропустит весь цикл. 
А поскольку переменной count было предварительно присвоено значение 0, count будет содержать правильное значение. 
Предположим, что первый прочитанный символ отличается от #. В этом случае программа входит в цикл, отображает символ, увеличивает значение счетчика count 
и читает следующий символ. Последний шаг жизненно важен. Без него цикл бесконечно обрабатывал бы первый введенный символ. Но благодаря этому последнему 
шагу, программа может перейти к следующему символу. Обратите внимание, что структура цикла следует упомянутым ранее правилам. 
Условие, прекращающее выполнение цикла — когда последним прочитанным символом является #. Это условие инициализируется первым чтением символа перед  
входом в цикл. Условие обновляется чтением следующего символа в конце тела цикла. 
Все это звучит вполне разумно. Но почему же программа не выводит пробелы? В этом виноват объект cin. Когда он читает значения типа char, как и при чтении 
других базовых типов, он пропускает пробелы и символы новой строки. Эти символы не отображаются и не могут быть подсчитаны. 
Чтобы еще более усложнить ситуацию, сообщим, что ввод в cin буферизуется. Это значит, что вводимые символы не попадут в программу до тех пор, пока не будет нажата клавиша <Enter>. 
Вот почему программа из листинга 5.16 позволяет печатать символы и после #. 
После нажатия <Enter> вся последовательность символов передается в программу, но программа прекращает обработку ввода после прочтения #. 
*/