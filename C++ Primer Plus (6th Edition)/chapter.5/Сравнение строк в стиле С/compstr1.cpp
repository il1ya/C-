/* В некоторых языках, таких как BASIC и стандартный Pascal, строки, сохраненные в массивах разных размеров, по определению не равны друг другу. 
Но строки в стиле С ограничиваются нулевым символом, а не размером содержащего их массива. 
Это значит, что две строки могут быть идентичными, даже если содержатся в массивах разного размера: 
char big[80] = "Daffy"; //5 букв плюс \0 
char little [6] = "Daffy"; // 5 букв плюс \0 
Кстати, хотя и нельзя применять операции отношений для сравнения строк, вы можете использовать их для сравнения символов, потому что символы относятся к целочисленным типам. 
Поэтому следующий код является допустимым, по крайней мере, для наборов символов ASCII и Unicode, для отображения символов по алфавиту: 
for (ch = 'a'; ch <= ' z'; ch++) 
cout <<  
сопрограмма в листинге 5.11 использует strcmpO в проверочном условии цикла for. Эта программа отображает слово, изменяет его первую букву, отображает его 
снова и продолжает это делать до тех пор, пока strcmpO не определит, что word содержит строку "mate". Обратите внимание на включение файла est ring — в нем содержится прототип stremp(). 
Листинг 5.11. compstrl.cрр */
// compstrl.срр — сравнение строк с использованием массивов 
#include <iostream>
#include <cstring> // прототип для strcmp()
int main(void)
{
    using namespace std;
    char word[5] = "?ate";
    for(char ch = 'a'; strcmp(word, "mate"); ch++)
    {
        cout << word << endl;
        word[0] = ch;
    }
    cout << "After loop ends, word is " << word << endl; // вывод word по завершении цикла 
    return 0;
}