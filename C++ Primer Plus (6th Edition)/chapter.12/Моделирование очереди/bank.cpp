/*
Моделирование работы банкомата 
Теперь у нас есть все инструменты, необходимые для моделирования работы банкомата. 
Программа должна запрашивать у пользователя три параметра: максимальный размер очереди, количество часов, которые моделируются программой, и среднее количество клиентов в час. 
Затем программа должна запустить цикл, каждое выполнение которого соответствует одной минуте моделируемого времени. 
Во время каждого такого минутного цикла должны выполняться перечисленные ниже шаги. 
1. Определить, появился ли новый клиент. Если да, то добавить клиента в очередь при условии, что для него есть место; иначе отклонить его. 
2. Если никто не обслуживается, выбрать из очереди первого человека. Определить время ожидания его обслуживания и занести в счетчик wait_time необходимое ему время обслуживания. 
3. Если в данный момент обслуживается клиент, уменьшить счетчик waittime на одну минуту. 
4 Вести подсчет различных параметров: количество обслуженных клиентов, количество отвергнутых клиентов, общее время, проведенное в ожидании в очереди, и общую длину очереди. 
После завершения цикла моделирования программа должна выдать статистический отчет. 
Интересной проблемой является определение, появился ли новый клиент. 
Предположим, что в среднем за час появляются 10 клиентов, т.е. один клиент каждые шесть минут. 
Программа вычисляет и сохраняет эту величину в переменной min_per_cust. 
Однако в реальности клиенты не будут появляться точно через 6 минут, и нужен более случайный процесс, который моделирует появление одного клиента в среднем за шесть минут. 
Для определения, появился ли клиент во время минутного цикла, в программе используется функция: 
bool newcustomer(double x) 
{ 
    return (std::rand() * x / RAND MAX < 1);
}
Вот как работает данный код. Значение RAND_MAX определено в файле cstdlib (ранее stdlib.h) и представляет собой наибольшее значение, которое может возвращать функция rand() (наименьшее равно 0). 
Предположим, что среднее время х между появлениями клиентов равно 6. 
Тогда значение rand() * х / RAND_MAX попадает куда-то в интервал от 0 до 6. В частности, оно будет меньше 1 в среднем одну шестую часть времени. 
Данная функция может выдать двух клиентов с промежутком в одну минуту, а может и с интервалом 20 минут. 
Такое нерегулярное поведение как раз и отличает реальные процессы от хронологически точных поступлений клиентов по одному каждые 6 минут. 
Данный метод не сможет работать, если среднее время между появлением клиентов меньше одной минуты, но наше моделирование и не предназначено для работы в таком напряженном режиме. 
Однако если понадобится эмулировать такую ситуацию, можно применить более подходящее временное разрешение — например, считать, что каждый цикл длится 10 секунд. 
Детали реализации моделирования представлены в листинге 12.12. 
Выполнение моделирования длительного периода времени позволяет оценить долгосрочные средние величины, а моделирование коротких промежутков дает краткосрочные вариации. 
Листинг 12.12. bank.срр */
// bank.срр -- использование интерфейса Queue 
// Компилировать вместе с queue.срр 
#include <iostream> 
#include <cstdlib>      // для rand() и srand() 
#include <ctime>        // для time() 
#include "queue.h" 
const int MIN_PER_HR = 60;
bool newcustomer(double x);                              // появился ли новый клиент? 
int main()
{
    using std::cin;
    using std::cout;
    using std::endl;
    using std::ios_base;

        // Подготовка 
    std::srand(std::time(0));                           // случайная инициализация rand() 
    cout << "Case Study: Bank of Heather Automatic Teller\n";
    cout << "Enter maximum size of queue: ";            // ввод максимального размера очереди 
    int qs;
    cin >> qs;
    Queue line(qs);                                     // очередь может содержать до qs людей 
    cout << "Enter the number of simulation hours: ";   // ввод количества эмулируемых часов 
    int hours;                                          // часы эмуляции 
    cin >> hours;
        // Эмуляция будет запускать один цикл в минуту 
    long cyclelimit = MIN_PER_HR * hours;               // количество циклов 
    cout << "Enter the average number of customers per hour: ";
        // Ввод количества клиентов в час 
    double perhour;                                     // среднее количество появлений за час 
    cin >> perhour;
    double min_per_cust;                                // среднее время между появлениями 
    min_per_cust = MIN_PER_HR / perhour;
    Item temp;                                          // данные нового клиента 
    long turnaways = 0;                                 // не допущены в полную очередь 
    long customers = 0;                                 // присоединены к очереди 
    long served = 0;                                    // обслуженные во время эмуляции
    long sum_line = 0;                                  // общая длина очереди
    int wait_time = 0;                                  // время до освобождения банкомата
    long line_wait = 0;                                 // общее время в очереди
        // Запуск моделирования 
    for(int cycle = 0; cycle < cyclelimit; cycle++)
    {
        if(newcustomer(min_per_cust))                   // есть подошедший клиент 
        {
            if(line.isfull())
                turnaways++;
            else
            {
                customers++;
                temp.set(cycle);                        // cycle = время прибытия 
                line.enqueue(temp);                     // добавление новичка в очередь 
            }
        }
        if(wait_time <= 0 && !line.isempty())
        {
            line.dequeue(temp);                          // обслуживание следующего клиента
            wait_time = temp.ptime();                    // в течение wait_time минут 
            line_wait += cycle - temp.when();
            served++;
        }
        if(wait_time > 0)
            wait_time--;
            sum_line += line.queuecount();
    }
    // Вывод результатов 
    if(customers > 0)
    {
        cout << "customers accepted: " << customers << endl;    // принято клиентов 
        cout << " customers served: " << served << endl;        // обслужено клиентов 
        cout << " turnaways: " << turnaways << endl;            // не принято клиентов 
        cout << "average queue size: ";                         // средний размер очереди 
        cout.precision(2); 
        cout.setf(ios_base::fixed, ios_base::floatfield); 
        cout << (double) sum_line / cyclelimit << endl; 
        cout << " average wait time: " << (double) line_wait / served << " minutes\n"; // среднее время ожидания (минут) 
    }
    else
        cout << "No customers!\n";                              // клиентов нет 
        cout << "Done!\n";
        return 0;
}
// x = среднее время в минутах между клиентами 
// возвращается значение true, если в эту минуту появляется клиент 
bool newcustomer(double x)
{
    return (std::rand() * x / RAND_MAX < 1);
}
/*
На заметку; 
Ваш компилятор может не воспринимать тип bool. В таком случае можно использовать int вместо bool — значение 0 вместо false и і вместо true. 
Возможно, также понадобится включить библиотеки stdlib.h и time.h вместо более новых cstdlib и ctime. 
Кроме того, может потребоваться самостоятельно определить rand_max. 
*/