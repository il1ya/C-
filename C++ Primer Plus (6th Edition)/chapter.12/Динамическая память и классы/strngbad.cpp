// Листинг 12.2. strngbad.cpp 
// strngbad.cpp -- методы класса StringBad 
#include <cstring> // в некоторых случаях — string.h 
#include "strngbad.h"
using std::cout;

// Инициализация статического члена класса 
int StringBad::num_strings = 0;
// Методы класса 
// Создание StringBad из С-строки 
StringBad::StringBad(const char *s)
{
    len = std::strlen(s);       // установка размера 
    str = new char[len + 1];    // выделение памяти 
    std::strcpy(str, s);        // инициализация указателя 
    num_strings++;              // счетчик объектов 
    cout << num_strings << ": \"" << str << "\" object created\n"; // для целей отладки 
}
StringBad::StringBad()          // конструктор по умолчанию 
{
    len = 4;
    str = new char[4];
    std::strcpy(str, "C++");    // строка по умолчанию 
    num_strings++;
    cout << num_strings << ": \"" << str << "\" default object created\n"; // для целей отладки 
}
StringBad::~StringBad()         // необходимый деструктор 
{
    cout << "\"" << str << "\" object deleted, "; // для целей отладки 
    --num_strings;              // является обязательным 
    cout << num_strings << " left\n"; // для целей отладки 
    delete [] str;              // является обязательным 
}
std::ostream & operator <<(std::ostream & os, const StringBad & st)
{
    os << st.str;
    return os;
}
/*
Прежде всего, обратите внимание на следующий оператор в листинге 12.2: 
int StringBad;:num_strings = 0; 
Этот оператор устанавливает первоначальное значение 0 для статического члена num_strings. 
Учтите, что статическую переменную-член нельзя инициализировать внутри объявления класса. 
Ведь объявление — это описание того, как выделяется память, но не само выделение. 
Память выделяется и инициализируется при создании объекта на основе данного формата. 
Для статического члена класса осуществляется независимая инициализация — с помощью отдельного оператора вне объявления класса. 
Это объясняется тем, что статический член класса хранится не в составе объектов. 
Обратите внимание, что оператор инициализации задает тип и указывает область действия, но не содержит ключевое слово static. 
Такая инициализация записывается в файле методов, а не в файле объявления класса, поскольку объявление класса содержится в заголовочном файле. 
Причина в том, что заголовочный файл может быть включен в несколько других файлов программы, и тогда оператор инициализации будет ошибочно выполнен несколько раз. 
Существует исключение, когда статические данные-члены все-таки инициализируются внутри объявления класса (см. главу 10) — 
если статический член данных определяется как константа целочисленного или перечислимого типа. 
*/