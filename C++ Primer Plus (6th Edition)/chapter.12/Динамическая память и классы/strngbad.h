/* Объекты классов StringBad и String содержат указатель на строку и значение, представляющее длину строки. 
Мы используем эти классы в основном для того, чтобы уяснить механизм работы new, delete и членов классов static. 
Поэтому конструкторы и деструкторы во время вызова будут выводить сообщения, помогающие проследить их работу. 
Зато для упрощения интерфейса класса мы опустим некоторые полезные функции-члены и дружественные функции (вроде перегруженных операций++ и ») и функцию преобразования. 
(Не переживайте, вопросы для самоконтроля в конце данной главы предоставят вам возможность добавить эти полезные функции.) 
Объявление класса приведено в листинге 12.1. 
Листинг 12.1. strngbad.h */
// strngbad.h -- несовершенное определение класса строки 
#include <iostream>
#ifndef STRNGBAD_H_
#define STRNGBAD_H_
class StringBad
{
    private:
        char *str;               // указатель на строку 
        int len;                 // длина строки 
        static int num_strings;  // количество объектов 
    public:
        StringBad(const char *s); // конструктор 
        StringBad();             // конструктор по умолчанию
        ~StringBad();            // деструктор
    // Дружественная функция
    friend std::ostream & operator <<(std::ostream & os, const StringBad & st);
};
#endif
/*
Класс называется StringBad — в качестве напоминания о том, что это пример незаконченной разработки. 
Сейчас разрабатывается класс с использованием распределения динамической памяти, и очевидные действия класс выполняет корректно. 
Например, в нем правильно используются операции new и delete в конструкторах и деструкторах. 
В принципе, в нем нет ничего "нехорошего", просто он не содержит реализацию некоторых дополнительных "хороших" вещей, которые необходимы, но совсем не очевидны. 
Когда мы уясним проблемы, связанные с этим классом, мы сможем понять и запомнить те неочевидные изменения, которые нужно будет сделать 
впоследствии, при преобразовании его в более функциональный класс String. 
Обратите внимание на два момента в этом объявлении. Во-первых, в нем для представления фамилии используется указатель на char, а не массив char. 
Это означает, что объявление класса не выделяет непосредственно память для строки. Для этого применяется операция new в конструкторах. 
Такая схема позволяет избежать привязки объявления класса к предопределенной границе размера строки. 
Во-вторых, в определении член num_strings объявлен как принадлежащий к классу хранения static. 
Статический член класса обладает особым свойством: программа создает только одну копию статической переменной класса независимо от количества создаваемых объектов. 
Другими словами, статический член совместно используется всеми объектами данного класса — как единый номер телефона для всех членов семьи. 
*/