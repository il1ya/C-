/*
До сих пор мы рассматривали переменные, имеющие область видимости в пределах файла, с внешним и внутренним связыванием. 
Теперь обсудим третий член семейства со статической продолжительностью хранения — локальную переменную без связывания. 
Такая переменная создается за счет применения модификатора static к переменной, определенной внутри блока. 
Если она используется внутри блока, модификатор static задает локальной переменной статическую продолжительность хранения. 
Это означает, что, несмотря на видимость переменной в пределах блока, она существует даже тогда, когда блок неактивен. 
Таким образом, статическая локальная переменная может сохранять свое значение между вызовами функции.
 (Статические переменные полезны для реинкарнации — их можно применять для передачи секретных номеров счетов швейцарского банка вашему следующему воплощению.) 
 Кроме того, если статическая локальная переменная инициализируется, это делается только один раз при запуске программы. 
 Последующие вызовы функции не будут приводить к повторной инициализации переменной, как это происходит в случае автоматических переменных. 
 Сказанное иллюстрируется в листинге 9.9. 
Листинг 9.9. static.срр */
// static.срр — использование статической локальной переменной 
#include <iostream>
// Константы 
const int ArSize = 10;
// Прототип функции 
void strcount(const char *str);
int main()
{
    using namespace std;
    char input[ArSize];
    char next;
    cout << "Enter a line: \n";
    cin.get(input, ArSize);
    while(cin)
    {
        cin.get(next);
        while(next != '\n')     // строка не помещается; 
            cin.get(next);      // избавиться от остатка 
        strcount(input);
        cout << "Enter next line (empty line to quit):\n";
        cin.get(input, ArSize);
    }
    cout << "Bye\n";
    return 0;
}

void strcount(const char *str)
{
    using namespace std;
    static int total = 0;   // статическая локальная переменная 
    int count = 0;          // автоматическая локальная переменная 
    cout << "\"" << str << "\" contains ";
    while(*str++)           // переход к концу строки 
        count++;
    total += count;
    cout << count << "characters\n";
    cout << total << " characters total\n";
}
/*
Кстати, программа в листинге 9.9 демонстрирует один из способов обработки вводимой строки, которая может превышать размер выделенного для нее массива. 
Вспомните, что метод ввода cin . get (input, ArSize) читает до конца экранной строки или до позиции ArSize-1, в зависимости от того, что случится раньше. 
Символ новой строки остается во входной очереди. Программа использует метод cin.get (next) для чтения символа, который следует после введенной строки. 
Если next является символом новой строки, значит, предыдущий вызов cin.get (input, ArSize) должен был прочитать целиком всю строку. 
Если next не является символом новой строки, в строке ввода остались непрочитанные символы. 
Затем в программе с помощью цикла отбрасывается оставшаяся часть строки, но код можно изменить так, чтобы остаток строки был задействован в следующем цикле ввода. 
Кроме того, в программе используется тот факт, что попытка чтения пустой строки с помощью get(char *, int) приводит к тому, что сіп возвращает false. 
Ниже показан вывод программы из листинга 9.9: 
Enter a line: 
nice pants 
"nice pant" contains 9 characters 
9 characters total 
Enter next line (empty line to quit): 
thanks 
"thanks" contains 6 characters 
15 characters total 
Enter next line (empty line to quit): 
parting is such sweet sorrow 
"parting i" contains 9 characters 
24 characters total 
Enter next line (empty line to quit): 
ok 
"ok" contains 2 characters 
26 characters total 
Enter next line (empty line to quit): 
Bye 
Обратите внимание, что поскольку размер массива равен 10, программа не считывает более 9 символов на строку. 
Кроме того, автоматическая переменная count сбрасывается в 0 при каждом вызове функции. 
Однако статическая переменная total устанавливается в 0 только один раз в начале. 
После этого total сохраняет свое значение между вызовами функций, что позволяет ее использовать для подсчета текущей суммы. 
*/