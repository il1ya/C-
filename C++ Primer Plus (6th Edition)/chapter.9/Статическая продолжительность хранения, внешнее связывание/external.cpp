/*
Тем не менее, хотя в программе могут присутствовать различные переменные с одинаковыми именами, каждая версия может иметь только одно определение. 
А что если определить внешнюю переменную и затем объявить обычную переменную с тем же самым именем внутри функции? 
Второе объявление интерпретируется как определение автоматической переменной. 
Эта автоматическая переменная находится в области видимости, когда программа выполняет эту конкретную функцию. 
Код в листингах 9.5 и 9.6 в случае совместной компиляции иллюстрирует использование внешней переменной в двух файлах и сокрытие глобальной переменной объявлением автоматической переменной с тем же именем! 
Программа также демонстрирует применение ключевого слова extern для повторного объявления внешней переменной, определенной ранее, а также использование операции разрешения контекста для реализации доступа к иначе скрытой внешней переменной. 
Листинг 9.5. external. ерр */
// external.ерр — внешние переменные 
// Компилировать вместе с support.ерр 
#include <iostream>
using namespace std;
// Внешняя переменная 
double warming = 0.3; // переменная warming определена 
// Прототипы функций 
void update(double dt);
void local();
int main() // использует глобальную переменную 
{
    cout << "Global warming is " << warming << " degrees.\n";
    update(0.1); // вызов функции, изменяющей warming 
    cout << "Global warming is " << warming << " degress.\n";
    local();    // вызов функции с локальной переменной warming 
    cout << "Global warming is " << warming << " degrees.\n";
    return 0;
}