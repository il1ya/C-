/*
Ради простоты в этом примере для обеспечения пространством памяти операции new с размещением используются два статических массива. 
Таким образом, для структуры chaff выделяется область памяти bufferl, а для массива из 20 элементов int — область памяти buffer2. 
Теперь, когда вы узнали, что такое операция new с размещением, рассмотрим пример программы. В листинге 9.10 оба вида операций new применяются для создания динамических массивов. 
В программе иллюстрируются некоторые важные различия между этими разновидностями new. Мы их обсудим после анализа вывода этой программы. 
Листинг 9.10. newplace.cpp */
// newplace.cpp — использование операции new с размещением 
#include <iostream>
#include <new>      // для операции new с размещением 
const int BUF = 512;
const int N = 5;
char buffer[BUF];   // блок памяти 
int main(void)
{
    using namespace std;
    double *pd1, *pd2;
    int i;
    // Вызов обычной и операции new с размещением 
    cout << "Calling new and placement new:\n";
    pd1 = new double[N];            // использование кучи 
    pd2 = new (buffer) double[N];   // использование массива buffer 
    for(i = 0; i < N; i++)
        pd2[i] = pd1[i] = 1000 + 20.0 * i;
    cout << "Memory addresses:\n" << "heap: " << pd1 << " static: " << (void *) buffer << endl; // вывод адресов памяти 
    cout << "Memory contents:\n";  // вывод содержимого памяти 
    for(i = 0; i < N; i++)
    {
        cout << pd1[i] << " at " << &pd1[i] << " ; ";
        cout << pd2[i] << " at " << &pd2[i] << endl;
    }
    // Вызов обычной и операции new с размещением во второй раз 
    cout << "\nCalling new and placement new a second time:\n";
    double *pd3, *pd4;
    pd3 = new double[N];            // нахождение нового адреса 
    pd4 = new (buffer) double[N];   // перезаписывание старых данных 
    for(i = 0; i < N; i++)
        pd4[i] = pd3[i] = 1000 + 40.0 * i;
    cout << "Memory contents:\n";
    for(i = 0; i < N; i++)
    {
        cout << pd3[i] << " at " << &pd3[i] << " ; ";
        cout << pd4[i] << " at " << &pd4[i] << endl;
    }
    // Вызов обычной и операции new с размещением в третий раз 
    cout << "\nCalling new and placement new a third time:\n";
    delete [] pd1;
    pd1 = new double[N];
    pd2 = new (buffer + N * sizeof(double)) double[N];
    for(i = 0; i < N; i++)
        pd2[i] = pd1[i] = 1000 + 60.0 * i;
        cout << "Memory contents:\n";
    for(i = 0; i < N; i++)
    {
        cout << pd1[i] << " at " << &pd1[i] << "; ";
        cout << pd2[i] << " at " << &pd2[i] << endl;
    }
    delete [] pd1;
    delete [] pd3;
    return 0;
}
/*
Ниже показан вывод программы из листинга 9.10 на одной из систем: 
Calling new and placement new: 
Memory addresses: 
heap: 006E4AB0 static: 00FD9138 
Memory contents: 
1000 at 006E4AB0; 1000 at 00FD9138 
1020 at 006E4AB8; 1020 at 00FD9140 
1040 at 006E4AC0; 1040 at 00FD9148 
1060 at 006E4AC8; 1060 at 00FD9150 
1080 at 006E4AD0; 1080 at 00FD9158 
Calling new and placement new a second time: 
Memory contents: 
1000 at 006E4B68; 1000 at 00FD9138 
1040 at 006E4B70; 1040 at 00FD9140 
1080 at 006E4B78; 1080 at 00FD9148 
1120 at 006E4B80; 1120 at 00FD9150 
1160 at 006E4B88; 1160 at 00FD9158 
Calling new and placement new a third time: 
Memory contents: 
1000 at 006E4AB0; 1000 at 00FD9160 
1060 at 006E4AB8; 1060 at 00FD9168 
1120 at 006E4AC0; 1120 at 00FD9170 
1180 at 006E4AC8; 1180 at 00FD9178 
1240 at 006E4AD0; 1240 at 00FD9180 

Замечания по программе 
Первое, что заслуживает внимания в листинге 9.10: операция new с размещением действительно помещает массив р2 в массив buffer; обе переменные р2 и buffer имеют значение 00FD9138. 
Тем не менее, они относятся к разным типам; рі — это указатель на double, тогда как buffer — указатель на char. 
(Кстати, именно поэтому в программе используется приведение (void *) для buffer; в противном случае cout попытается отобразить строку.) 
Между тем, обычная операция new выделяет массиву рі адрес памяти с более высоким значением — 006Е4АВ0, который принадлежит динамически управляемой куче. 
Второй момент, который следует отметить, состоит в том, что второе обращение к обычной операции new приводит к нахождению другого блока памяти — начинающегося с адреса 006Е4В68. 
Однако второе обращение к операции new с размещением приводит к использованию того же блока памяти, что и прежде. Этот блок начинается с адреса 00FD9138. 
Важный факт здесь в том, что операция new с размещением просто использует адрес, переданный в качестве аргумента; 
она не анализирует, свободна ли указанная область памяти, а также не ищет блок неиспользуемой памяти. 
В результате часть забот об управлении памятью возлагается на программиста. 
Например, при третьем обращении к операции new с размещением задается смещение в массиве buffer, чтобы использовалась новая область памяти: 
pd2 = new(buffer + N * sizeof (double)) double [N]; // смещение на 40 байт 
Третий момент касается наличия или отсутствия операции delete. 
Для обычной операции new следующий оператор освобождает блок памяти, начинающийся с адреса 006Е4АВ0; в результате следующее обращение к new может повторно использовать тот же самый блок: 
delete [] pdl; 
В противоположность этому программа из листинга 9.10 не использует delete для освобождения памяти, выделенной операцией new с размещением. 
На самом деле, в этом случае подобное невозможно. 
Область памяти, указанная переменной buffer, является статической, a delete может использоваться только с указателем на область памяти в куче, которая выделена обычной операцией new. 
Другими словами, массив buffer не подпадает под полномочия операции delete, поэтому следующий оператор вызовет ошибку времени выполнения: 
delete [] pd2; // не работает 
С другой стороны, если бы для создания буфера памяти применялась обычная операция new, для освобождения всего блока памяти понадобилось бы обратиться к операции delete. 
Использовать операцию new с размещением можно и другим способом комбинировать ее с инициализацией для помещения информации по определенному аппаратному адресу. 
Вас может заинтересовать, что конкретно делает операция new с размещением. 
В основном она лишь возвращает переданный ей адрес, приводя его к типу void *, чтобы его можно было присваивать любому типу указателя. 
Однако так работает стандартная операция new с размещением. C++ позволяет программистам перегружать эту операцию. 
Ситуация усложняется, когда операция new с размещением используется для объектов классов. Эта тема будет продолжена в главе 12. 
*/