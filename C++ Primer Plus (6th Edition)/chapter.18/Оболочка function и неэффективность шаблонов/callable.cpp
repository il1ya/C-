// Далее программа в листинге 18.7 вызывает шаблонную функцию use_f() шесть раз. 
// Листинг 18.7. callable.срр 
// callable.срр — вызываемые типы и шаблоны 
#include "somedefs.h"
#include <iostream>
double dub(double x) 
{
    return 2.0 * x;
}
double square(double x)
{
    return x * x;
}
int main()
{
    using std::cout;
    using std::endl;
    double y = 1.21;
    cout << "Function pointer dub:\n";      // указатель на функцию dub 
    cout << " " << use_f(y, dub) << endl;
    cout << "Function pointer square:\n";   // указатель на функцию square 
    cout << " " << use_f(y, square) << endl;
    cout << "Function object Fp:\n";        // функциональный объект Fp 
    cout << " " << use_f(y, Fp(5.0)) << endl;
    cout << "Function object Fq:\n";        // функциональный объект Fq 
    cout << " " << use_f(y, Fq(5.0)) << endl;
    cout << "Lambda expression 1:\n";       // лямбда-выражение 1 
    cout << " " << use_f(y, [](double u){return u*u;}) << endl;
    cout << "Lambda expression 2:\n";       // лямбда-выражение 2 
    cout << " " << use_f(y, [](double u) {return u+u / 2.0;}) << endl;
    return 0;
}
/*
Для каждого вызова параметр шаблона Т установлен в тип double. А что с параметр шаблона F? Каждый раз фактический аргумент является чем-то таким, что  
принимает аргумент типа double и возвращает значение типа double, поэтому может показаться, что F будет иметь тот же самый тип для всех шести вызовов usef(), и 
экземпляр шаблона должен создаваться только один раз. Но, как показывает следующий пример вывода, это не так: 
Function pointer dub: 
use_f count = 1, &count = 0x402028 
2.42 
Function pointer square: 
use_f count = 2, &count = 0x402028 
1.1 
Function object Fp: 
use_f count = 1, &count = 0x402020 
6.05 
Function object Fq: 
use_f count = 1, &count = 0x402024 
6.21 
Lambda expression 1: 
use_f count = 1, &count = 0x405020 
1.4641 
Lambda expression 2: 
use_f count = 1, &count = 0x40501c 
1.815 
Шаблонная функция use_f() имеет статический член count, и с помощью его адреса можно посмотреть, сколько экземпляров было создано. 
В выводе присутствуют пять разных адресов, так что должно быть пять различных экземпляров шаблона use_f(). 
Чтобы узнать, что происходит, необходимо посмотреть, как компилятор определяет тип параметра шаблона F. 
Для начала взгляните на следующий вызов: use_f(у, dub); 
Здесь dub — это имя функции, которая принимает аргумент double и возвращает значение double. 
Имя функции является указателем, следовательно, параметр F получает тип double(*)(double) , т.е. указатель на функцию с аргументом double и возвращаемым значением double. 
Далее производится такой вызов: use_f(y, square); 
Здесь снова второй аргумент имеет тип double (*) (double), поэтому данный вызов использует тот же экземпляр use_f(), что и первый вызов. 
Следующие два вызова use_f() передают объекты во втором аргументе, так что F получает, соответственно, тип Fp и Fq, и мы имеем два новых экземпляра для этих значений F. 
Наконец, в последних двух вызовах F устанавливается в любые типы, которые компилятор использует для лямбда-выражений. 
*/