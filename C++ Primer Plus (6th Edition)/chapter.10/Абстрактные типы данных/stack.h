/*
Раздел private должен позаботиться о хранении данных. Например, можно использовать обычный массив, динамически распределенный в памяти массив либо  
какую-то более развитую структуру данных вроде связного списка. 
Однако открытый интерфейс класса должен скрывать точные детали представления. Наоборот, он должен быть выражен в общих понятиях, таких как создание стека, заталкивание элемента и т.д. 
В листинге 10.10 показан один из возможных подходов. Предполагается, что тип bool реализован. 
Если же это не так, то вместо bool с false и true можно использовать int со значениями 0 и 1. 
Листинг 10.10. stack.h */
// stack.h -- определение класса для абстрактного типа данных — стека 
#ifndef STACK_H_
#define STACK_H_

typedef unsigned long Item;
class Stack
{
    private:
        enum {MAX = 10}; // константа, специфичная для класса 
        Item items[MAX]; // хранит элементы стека 
        int top;         // индекс вершины стека 
    public:
        Stack();
        bool isempty() const;
        bool isfull() const;
        // push() возвращает false, если стек полон, и true - в противном случае 
        bool push(const Item * item);   // добавляет элемент в стек 

        // pop() возвращает false, если стек пуст, и true - в противном случае 
        bool pop(Item &item);           // выталкивает элемент с вершины стека 
};
#endif

/*
В примере, приведенном в листинге 10.10, раздел private показывает, что стек реализован с помощью массива, но раздел public никак не отражает этот факт. 
То есть обычный массив можно заменить, скажем, динамическим массивом, не меняя интерфейс класса. 
Это означает, что изменение реализации стека не требует внесения изменений в код программы, которая будет его использовать. 
Вы просто перекомпилируете код реализации стека и скомпонуете его с кодом программы. 
Представленный интерфейс несколько избыточен, т.к. pop() и push() возвращают информацию о состоянии стека (пуст или полон) вместо того, чтобы иметь тип void. 
Это обеспечивает дополнительные возможности по управлению переполнением стека и его очисткой. 
Можно использовать isempty() и isfull() для проверки перед попытками модификации стека или с помощью возвращаемых значений push() и pop() определять, удалась ли соответствующая операция. 
Вместо того чтобы определять стек в терминах некоторого конкретного типа, класс описывает его в терминах общего типа Item. 
В данном случае заголовочный файл использует typedef для указания, что Item является unsigned long. 
Если вы хотите создать стек для хранения элементов типа double или структур, измените typedef, а объявление класса и определения методов останутся прежними. 
Шаблоны классов (см. главу 14) предлагают более мощный метод изоляции типа хранимых данных от проектного решения класса. 
*/