/* Кроме того, класс Stonewt предоставляет две функции отображения. 
Одна отображает вес в фунтах, другая — в стоунах и фунтах. 
В листинге 11.17 показана реализация методов класса. Обратите внимание, что каждый конструктор присваивает значения всем трем закрытым членам. 
Таким образом, при создании объекта Stonewt автоматически устанавливаются оба представления веса. 
Листинг 11.17. stonewt.срр */
// stonewt.срр -- методы класса Stonewt 
#include <iostream>
using std::cout;
#include "stonewt.h"
// Конструирует объект Stonewt из значения типа double 
Stonewt::Stonewt(double lbs)
{
    stone = int(lbs) / Lbs_per_stn; // целочисленное деление 
    pds_left = int(lbs) % Lbs_per_stn + lbs - int(lbs);
    pounds = lbs;
}
// Конструирует объект Stonewt из стоунов и значения типа double 
Stonewt::Stonewt(int stn, double lbs)
{
    stone = stn;
    pds_left = lbs;
    pounds = stn * Lbs_per_stn + lbs;
}
Stonewt::Stonewt() // конструктор по умолчанию, wt = 0 
{
    stone = pounds = pds_left = 0;
}
Stonewt::~Stonewt() // деструктор
{

}
// Отображение веса в стоунах 
void Stonewt::show_stn() const
{
    cout << stone << " stone, " << pds_left << " pounds\n";
}
// Отображение веса в фунтах 
void Stonewt::show_lbs() const
{
    cout << pounds << " pounds\n";
}
/*
Поскольку объект Stonewt представляет единственный вес, имеет смысл предусмотреть способы для преобразования целочисленного или значения с плавающей точкой в объект Stonewt. 
И это уже сделано. В C++ любой конструктор, который принимает единственный аргумент, действует как инструмент копирования для преобразования значения типа аргумента в тип класса. 
Следующий конструктор служит инструкциями для преобразования значения типа double в значение типа Stonewt: 
Stonewt(double lbs); // шаблон преобразования double в Stonewt 
То есть можно записать такой код: 
Stonewt myCat; // создание объекта Stonewt 
myCat =19.6; // использование Stonewt(double) 
// для преобразования 19.6 в Stonewt 
Программа использует конструктор Stonewt (double) для построения временного объекта Stonewt с указанием 19. 6 в качестве инициализирующего значения. 
Затем операция почленного присваивания копирует содержимое временного объекта в myCat. 
Этот процесс известен как неявное преобразование, поскольку происходит автоматически, без необходимости в явном приведении типов. 
В качестве функции преобразования может использоваться только конструктор с одним аргументом. 
Следующий конструктор принимает два аргумента, поэтому применяться для преобразования типов не может: 
Stonewt(int stn, double lbs); // не является функцией преобразования 
Однако если предусмотреть в нем значение по умолчанию для второго параметра, он сможет действовать как руководство для преобразования int: 
Stonewt(int stn, double lbs = 0); // преобразование int в Stonewt 
Возможность применения конструктора, работающего как автоматическая функция преобразования типов, кажется удобным средством. 
Но программисты,  накопившие определенный опыт работы с C++, обнаруживают, что автоматический аспект не всегда желателен, поскольку иногда ведет к неожиданным преобразованиям. 
Поэтому в C++ добавлено новое ключевое слово explicit для отключения этого автоматического поведения. 
Значит, конструктор можно объявить следующим образом: 
explicit Stonewt (.double lbs); // неявное преобразование не разрешено 
Это отключает неявное преобразование, подобное тому, что приведено в предыдущем примере, но по-прежнему позволяет использовать явное преобразование, т.е. 
с явными приведениями типов: 
Stonewt myCat;  // создание объекта Stonewt 
myCat =19.6;    // не допускается, если Stonewt(double) 
// объявлен как explicit 
mycat = Stonewt(19.6); // так можно, явное преобразование 
mycat = (Stonewt) 19.6; // так можно, это старая форма приведения типов 
*/