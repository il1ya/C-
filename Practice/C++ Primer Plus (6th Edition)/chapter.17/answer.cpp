Вопросы для самопроверки 
1. Какую роль играет файл iostream во вводе-выводе C++? 
1. Файл iostream определяет классы, константы и манипуляторы, которые используются для управления вводом и выводом. 
Эти объекты управляют потоками и буферами, применяемыми при обработке ввода-вывода. Этот файл также создает стандартные объекты 
(cin, cout, cerr и clog и их эквиваленты для расширенных символов), которые используются для обработки стандартных потоков ввода и вывода, связанных с каждой программой. 

2. Почему ввод числа 121с клавиатуры требует от программы выполнения преобразования? 
2. При вводе с клавиатуры генерируется последовательность символов. При вводе 121 генерируются три символа, и каждый из них представляется однобайтным двоичным кодом. 
Если значение необходимо сохранить как int, то эти три символа должны быть преобразованы в одно двоичное представление значения 121. 

3. В чем состоит различие между потоком стандартного вывода и стандартным потоком ошибок? 
3. По умолчанию стандартный вывод и стандартные ошибки отправляют вывод на стандартное устройство вывода, которым обычно является монитор. 
Однако если ваша операционная система перенаправит вывод в файл, то стандартный вывод будет связан с файлом, а не с экраном, но стандартные ошибки — с экраном. 

4. Почему cout может отображать различные типы C++ без необходимости явного указания инструкций для каждого типа? 
4. Класс ostream определяет версию функции operator<<() для каждого базового типа C++. Компилятор интерпретирует выражение вроде 
cout << spot 
следующим образом: 
cout.operator<<(spot) 
Затем он может сопоставить этот вызов метода с прототипом функции, имеющей такой же тип аргумента. 

5. Какое свойство определений методов вывода позволяет выполнять конкатенацию вывода? 
5. Можно связать методы вывода, возвращающие тип ostream &. В результате метод будет вызываться посредством объекта для возврата этого объекта.  
Возвращенный объект впоследствии может активизировать следующий метод в последовательности. 

6. Напишите программу, которая запрашивает целое число и затем отображает его в десятичной, восьмеричной и шестнадцатеричной формах. 
Отобразите все формы в одной и той же строке, в полях шириной по 15 символов, с применением префиксов C++ для оснований систем счисления. 
#include <iostream>
#include <iomanip>
int main()
{
    using namespace std;
    cout << "Enter an integer: ";
    int n;
    cin >> n;
    cout << setw(15) << "base ten" << setw(15) << "base sixteen" << setw(15) << "base eight" << "\n";
    cout.setf(ios::showbase);       // или cout << showbase; 
    cout << setw(15) << n << hex << setw(15) << n << oct << setw(15) << n << "\n";
    return 0;
}

8. Пусть имеется следующая программа: 
//rql7-8.cpp 
#include <iostream> 
int main() 
{ 
    using namespace std; 
    char ch; 
    int ctl = 0; 
    cin >> ch; 
    while (ch != 'q') 
    { 
        ctl++; 
        cin >> ch; 
    } 
    int ct2 = 0; 
    cin.get(ch); 
    while (ch != 'q') 
    {    
        ct2++; 
        cin.get(ch); 
    } 
    cout << "ctl = " << ctl << "; ct2 = " << ct2 << "\n"; 
    return 0; 
} 
Что она напечатает, если получит следующий ввод: 
I see a q<Enter> 
I see a q<Enter> 
Здесь <Enter> означает нажатие одноименной клавиши. 
8. Вывод программы выглядит следующим образом: 
ctl = 5; ct2 = 9 
Первая часть программы игнорирует пробелы и символы новой строки, а вторая часть — нет. 
Обратите внимание, что вторая часть программы начинает чтение с символа новой строки, который следует за первым q, и воспринимает символ новой строки как часть строки. 

9. Оба следующих оператора читают и отбрасывают символы, вплоть до конца строки, включая его. Чем различается их поведение? 
while(cin.getO != '\n') 
    continue; 
cin.ignore(80, '\n'); 
9. Форма ignore() будет порождать сбойные ситуации, если строка ввода превысит 80 символов. В этом случае будут пропускаться только первые 80 символов. 
