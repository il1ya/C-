1. Пусть класс String содержит следующие закрытые члены: 
class String 
    { 
        private: 
        char  *str;     // указывает на строку, распределенную операцией new 
        int len;        // хранит длину строки 
}; 
а. Что неправильно в следующем конструкторе по умолчанию? 
String::String() {} 
1. а. Синтаксис правильный, но этот конструктор оставляет неинициализированным указатель str. 
Конструктор должен либо установить указатель в NULL, либо использовать операцию new[] для инициализации указателя. 

б. Что неправильно в следующем конструкторе? 
String::String(const char *s) 
{ 
    str = s; 
    len = strlen(s); 
} 
б. Этот конструктор не создает новую строку, а просто копирует адрес старой строки. Следует использовать new[] и strcру(). 

в. Что неправильно в следующем конструкторе? 
String::String(const char *s) 
{ 
    strcpy(str, s); 
    len = strlen (s); 
} 
в. Этот конструктор копирует строку, не выделяя память для ее хранения. Чтобы выделить соответствующий объем памяти, необходимо использовать: 
new char [len + 1] 

2. Назовите три проблемы, которые могут возникнуть при определении класса, в котором указатель-член инициализируется с помощью операции new. 
Укажите, как их можно устранить. 
2. Во-первых, когда объект этого типа прекращает работу, данные, на которые указывает указатель-член объекта, остаются в памяти, занимая пространство и оставаясь недоступными, поскольку указатель был утрачен. 
Эту ситуацию можно исправить с помощью деструктора класса, который освободит память, выделенную операцией new в функциях конструкторов. 
Во-вторых, после того как деструктор освободит эту память, он может попытаться освободить ее еще раз, если в программе производилась инициализация одного объекта другим. 
Это объясняется тем, что при инициализации одного объекта другим по умолчанию копируется значение указателя, но не данные, на которые он указывает, в результате чего появляются два указателя на одни и те же данные. 
Решение состоит в том, чтобы определить конструктор копирования класса, благодаря которому при инициализации копировались бы данные, на которые указывает указатель. 
В-третьих, присваивание одного объекта другому может привести к аналогичной ситуации, когда два указателя будут указывать на одни и те же данные. 
Решение состоит в перегрузке операции присваивания, которая обеспечит копирование данных, а не указателей. 

3. Какие методы класса компилятор генерирует автоматически, если они не представлены явно? Опишите, как ведут себя эти неявно сгенерированные функции. 
3. C++ автоматически предоставляет следующие функции-члены: 
• конструктор по умолчанию, если не определено ни одного конструктора; 
• конструктор копирования, если он не определен; 
• операция присваивания, если она не определена; 
• деструктор по умолчанию, если он не определен; 
• операция взятия адреса, если она не определена. 
Конструктор по умолчанию ничего не делает, однако позволяет объявлять массивы и неинициализированные объекты. 
Конструктор копирования и операция присваивания, предлагаемые по умолчанию, используют почленное присваивание. 
Деструктор по умолчанию ничего не делает. Неявная операция взятия адреса возвращает адрес вызывающего объекта (т.е. значение указателя this). 


4. Найдите и исправьте ошибки в следующем объявлении класса: 

class nifty
{
    private:
        char personality[40];
        int talents;
    public:
        nifty();
        nifty(const char *s);
        friend ostream &operator<<(ostream &os, const nifty &n);
};

nifty::nifty()
{
    personality[0] = '\0';
    talents = 0;
}
nifty::nifty(const char *s)
{
    strcpy(personality, s);
    talents = 0;
}
ostream &nifty::operator <<(ostream & os, const nifty &n)
{
    os << n.personality << '\n';
    os << n.talent << '\n';
    return os;
}

5. Имеется следующее объявление класса: 
class Golfer 
{ 
    private: 
        char *fullname;     // указывает на строку, содержащую имя игрока в гольф 
        int games;          // хранит количество сыгранных игр 
        int * scores;       // указывает на первый элемент массива счетов игр 
    public: 
    Golfer(); 
    Golfer(const char *name, int g = 0); 
    // Создает пустой динамический массив из g элементов, если g > 0 
    Golfer(const Golfer &g); 
    ~Golfer(); 
}; 

а. Какие методы класса будут вызываться следующими операторами? 
Golfer nancy;                       // #1 конструктор по умолчанию Golfer(); 
Golfer lulu("Little Lulu");         // #2 Golfer(const char *name, int g = 0); 
Golfer roy("Roy Hobbs", 12);        // #3 Golfer(const char *name, int g = 0); 
Golfer *par = new Golfer;           // #4 Golfer();
Golfer next = lulu;                 // #5 Golfer(const Golfer &g); 
Golfer hazzard = "Weed Thwacker";   // #6 Golfer(const char *name, int g = 0); 
*par = nancy;                       // #7 // операцию присваивания по умолчанию
nancy = "Nancy Putter";             // #8 Golfer(const char *name, int g = 0); операцию присваивания по умолчанию

б. Ясно, что классу требуется больше методов для того, чтобы он был действительно полезным. 
Какой дополнительный метод нужен для защиты данных от разрушения? 
б. Класс должен определять операцию присваивания, которая копирует данные, а не адреса. 
