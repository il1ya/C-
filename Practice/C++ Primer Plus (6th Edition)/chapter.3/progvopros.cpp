1. Почему в языке C++ имеется более одного целочисленного типа? 
1. более удобного программирования зависимости от объема данных
Наличие более одного целочисленного типа позволяет выбрать такой тип, который наиболее точно подходит под конкретные требования. 
Например, можно было бы использовать short для экономии памяти или long для обеспечения нужного объема памяти либо увеличения скорости вычислений. 


2. Объявите переменные согласно перечисленным ниже описаниям. 
а. Целочисленная переменная short, имеющая значение 80. 
short name = 80;
б. Целочисленная переменная unsigned int, имеющая значение 42.110. 
unsigned int name = 42110
в. Целочисленная переменная, имеющая значение 3 000 000 000. 
unsigned long name = 3 000 000 000

Если ваша система поддерживает универсальную списковую инициализацию, можно использовать следующий код: 
short rbis = {80}; // знак = не обязателен 
unsigned int q {42110}; // можно было бы использовать = {42110} 
long long ants {3000000000}; 


3. Какие меры предпринимаются в C++, чтобы не допустить превышения пределов целочисленного типа? 
3. C++ не предоставляет автоматической защиты от превышения целочисленных пределов; чтобы узнать об ограничениях, можно воспользоваться заголовочным файлом climits. 

4. В чем состоит различие между 33L и 33? 
33L long, 33 int
Константа 33L имеет тип long, а константа 33 — тип int. 

5. Взгляните на следующие два оператора C++: 
char grade = 65; 
char grade = 'A'; 
Являются ли они эквивалентными? 
int = 65  'A' char
Эти два оператора не эквивалентны друг другу, хотя в некоторых системах результат их выполнения будет одинаковым. 
Более важно то, что первый оператор присваивает букву А переменной grade только в той системе, в которой  
используется код ASCII, а второй оператор работает для других кодировок. Кроме того, 65 является константой int, a 'A' — константой char. 


6. Как в C++ определить, какой символ представляется кодом 88? Сделайте это, по крайней мере, двумя способами. 
6.  char name = 88;
    cout << name << endl;
char с = 88; 
cout << с << endl; // тип char выводит символ 
cout.put(char(88)); // put() выводит char в виде символа 
cout « char (88) « endl; // новый стиль приведения значения к типу char 
cout « (char) 88 « endl; // старый стиль приведения значения к типу char 


7. Присваивание значения типа long переменной типа float может привести к ошибке округления. 
А что произойдет, если присвоить значение long переменной double? И что будет, если присвоить значение long long переменной double? 
7. Ответ зависит от того, сколько байтов содержат эти типы. Если тип long занимает 4 байта, то потерь не будет. 
Это объясняется тем, что наибольшим значением типа long является примерно 2 миллиарда, что составляет 10 цифр. 
Поскольку double предлагает как минимум 13 значащих цифр, округление не является необходимым. 
С другой стороны, тип long long может достигать 19 цифр, что превышает 13 значащих цифр, гарантированных для double. 


8. Вычислите следующие выражения: 
а. 8 * 9 + 2 = 74
б. 6 * 3 / 4 = 4
в. 3 / 4 * б = 0
г. 6.0 * 3 / 4 = 4
д. 15 % 4 = 3;

9. Предположим, что хі и х2 являются переменными типа double, которые вы хотите просуммировать как целые числа, а полученный результат присвоить целочисленной переменной. 
Напишите для этого необходимый оператор C++. Что если вы хотите просуммировать их как значения double, а затем  преобразовать результат в int? 
Для решения первой задачи подойдет один из следующих вариантов: 
int pos = (int) xl + (int) x2; 
int pos = int (xl) + int (x2); 
Чтобы сложить их как тип double и затем преобразовать, можно  
воспользоваться одним из следующих операторов: 
int pos = (int) (xl + x2); 
int pos = int (xl + x2); 


10. Каким будет тип переменной в каждом из следующих объявлений? 
a.auto cars = 15;  int
б.auto iou = 150.37f; float
в.auto level = 'В'; char
г.auto crat = U' /U00002155'; char32_t
д.auto fract = 8.25f/2.5; double


