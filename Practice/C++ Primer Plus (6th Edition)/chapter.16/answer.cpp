1. Пусть имеется следующее объявление класса: 
class RQ1 
{ 
    private: 
        char * st;  // указатель на строку в стиле С 
    public: 
    RQK) { st = new char [1]; strcpy (st, "") ; } 
    RQ1(const char * s) 
    {st = new char [strlen(s) + 1]; strcpy (st, s) ; } 
    RQ1 (const RQ1 & rq) 
    {st = new char [strlen (rq.st) + 1] ; strcpy (st, rq.st); } 
    ~RQ1 () {delete [] st}; 
    RQ & operator= (const RQ & rq) ; 
                    // Другие операторы 
}; 
Преобразуйте его в объявление, использующее объект string. Какие методы больше не нуждаются в явных определениях? 
1. 
#include <string>
using namespace std;
class RQ1{
    private:
        string st; // обьект string
    public:
        RQ1() : st("") {}
        RQ1(const char *s) : st(s) {}
        ~RQ1() {};
        // дополнительный код
};
Явные конструктор копирования, деструктор и операция присваивания больше не нужны, поскольку объект string самостоятельно управляет памятью. 

2. Назовите хотя бы два преимущества объектов string по сравнению со строками в стиле С с точки зрения простоты применения.
2. Один объект string можно присвоить другому. Объект string самостоятельно управляет памятью, поэтому обычно не нужно заботиться о превышении  
строкой объема памяти, которым обладает содержащий ее объект. 

3. Напишите функцию, которая принимает ссылку на объект string в качестве аргумента и затем преобразует объект string в прописные буквы. 
3. 
#include <string>
#include <cctype>
using namespace std;
void ToUpper(string &str)
{
    for(int i = 0; i < str.size(); i++)
        str[i] = toupper(str[i]);
}

4. Какие из следующих операторов не являются примерами корректного использования (концептуально или синтаксически) объекта auto_ptr? 
(Предполагается, что все необходимые заголовочные файлы включены.) 
    auto_ptr<int> pia(new int[20]); // неправильно, необходимо использовать new, а не new [] 
    auto_ptr<string> (new string);  // неправильно, отсутствует имя указателя 
    int rigue = 7; 
    auto_ptr<int>pr(&rigue);        // неправильно, память не выделена с помощью операции new 
    auto_ptr dbl (new double);      // неправильно, пропущено <double> 

5. Если бы можно было создать механический эквивалент стека, который хранит клюшки для гольфа вместо номеров, почему он был бы (концептуально) плохой сумкой для гольфа?
5. Принцип LIFO в стеке означает, что может понадобиться удалить множество клюшек для гольфа, прежде чем будет найдена необходимая. 

6. Почему контейнер set — неудачный выбор для хранения записей о полученных очках в гольфе в формате "от лунки к лунке"? 
6. Контейнер set будет хранить только одну копию каждого значения, поэтому, скажем, пять очков из 5 будут храниться как одно число 5. 

7. Если указатель — это итератор, почему разработчики STL просто не используют его вместо итераторов?
7. Итераторы позволяют использовать объекты с интерфейсом, подобным указателям, для перемещения по данным, организованным не в виде массива (например, данные в двухсвязном списке). 

8. Почему разработчики STL не определили базовый класс итератора, используя наследование для порождения классов для других типов итераторов, 
и не выразили алгоритмы в терминах этих классов итераторов? 
8. Подход, реализованный в STL, позволяет функциям STL использоваться с обычными указателями на обычные массивы, а также с итераторами для  
контейнерных классов STL, подобным образом увеличивая их универсальность. 

9. Приведите, как минимум, три примера, показывающих преимущества объекта vector по сравнению с обычным массивом.
9. Можно присваивать один объект vector другому. Объект vector управляет собственной памятью, поэтому можно вставлять элементы в вектор, а он будет автоматически изменять свои размеры. 
С помощью метода at() можно инициировать автоматическую проверку границ. 

10. Если в коде из листинга 16.9 использовать list вместо vector, то какие части программы станут некорректными? Легко ли они могут быть исправлены? Если да, то как? 
10. Две функции sort() и функция random_shuffle() требуют итератора с произвольным доступом, тогда как объект list имеет только двунаправленный итератор. 
Для сортировки можно использовать функции-члены sort() шаблонного класса списка (см. приложение Ж) вместо функций общего назначения, однако нет функции-члена, эквивалентной random_shuffle(). 
Тем не менее, можно скопировать список в вектор, перетасовать вектор и скопировать результат обратно в список. 
