Вопросы для самоконтроля 
1. Что неверно в следующих попытках создания дружественных конструкций: 
а.  
class snap{ 
        friend clasp; 
}; 
class clasp { ... }; 
а. Объявление дружественного класса должно выглядеть следующим образом: 
    friend class clasp; 

б. 
class cuff{ 
    public: 
        void snip(muff &) { ... } 
}; 
class muff{ 
friend void cuff::snip(muff &); 
}; 

б. Для этого необходимо упреждающее объявление, чтобы компилятор мог интерпретировать void snip (muff &): 
class muff;     // упреждающее объявление 
class cuff { 
    public: 
        void snip (muff &) { ... } 
}; 
class muff{ 
friend void cuff: : snip (muff &); 
}; 


в. 
class muff{ 
friend void cuff::snip(muff &); 
}; 
class cuff{ 
    public: 
void snip(muff &) { ... } 
};

в. Во-первых, объявление класса cuff должно предшествовать классу muff, чтобы компилятор мог воспринять cuff::snip(). 
Во-вторых, компилятору необходимо упреждающее объявление muff, чтобы он мог воспринять snip (muff &): 
class muff;     // упреждающее объявление 
class cuff{ 
    public: 
void snip(muff &) { ... } 
}; 
class muff{ 
    friend void cuff: :snip(muff &); 
}; 


2. Вы уже видели, как создаются взаимно дружественные классы. 
Возможно ли создать более ограниченную форму отношения дружественности, при котором только некоторые члены класса В являются друзьями для класса А и некоторые члены класса А — друзьями для В? 
Обоснуйте свой ответ. 
2. Нет. Чтобы класс А имел друга, являющегося функцией-членом класса В, объявление В должно предшествовать объявлению А. 
Упреждающего объявления не будет достаточно, поскольку оно сообщит классу А, что В является классом, однако не будет показывать имена членов класса. 
Аналогично, если В имеет друга, который является функцией-членом А, то итоговое объявление А должно предшествовать объявлению В. Оба эти требования исключают друг друга. 


3. Какие проблемы могут возникнуть в следующем объявлении вложенного класса? 
class Ribs 
{ 
    private: 
        class Sauce 
        { 
            int soy; 
            int sugar; 
    public: 
        Sauce(int si, int s2) : soy(sl), sugar(s2) { } 
        }; 
}; 

3. Доступ к классу возможен только через его открытый интерфейс; это означает, что единственное, что вы можете сделать с объектом Sauce — это вызвать конструктор для его создания. 
Другие члены (soy и sugar) являются закрытыми по умолчанию. 


4. В чем состоит различие между throw и return? 
4. throw возращает ошибку пойманую в catch. return же значение функций.

4. Предположим, что функция f1() вызывает функцию f2(). Оператор возврата в f2() возобновляет выполнение программы со следующего оператора после вызова функции f2() в функции f1(). 
Оператор throw возвращает программу через существующую последовательность вызовов функций до блока try, который прямо или косвенно содержит вызов функции f2(). 
Он может находиться в fl() или в функции, вызывающей функцию f2(), и т.д. Отсюда выполнение передается следующему совпавшему блоку catch, а не первому оператору после вызова функции. 


5. Предположим, что имеется иерархия классов исключений, порожденная от базового класса исключений. В каком порядке следует расположить блоки catch? 
5. Блоки catch необходимо упорядочить от наиболее глубокого в цепочке наследования до наименее глубокого. 

6. Рассмотрим классы Grand, Superb и Magnificent, определенные в настоящей главе. 
Пусть рд — указатель типа Grand *, которому присвоен адрес объекта одного из этих трех классов, a ps — указатель типа Superb *. 
В чем разница в поведении двух следующих примеров кода? 
if (ps = dynamic_cast<Superb *>(pg)) 
    ps->say();              // пример #1 

if (typeid(*pg) == typeid(Superb)) 
    (Superb *) pg)->say();  // пример #2 

6. В примере #1 условие if равно true, если pg указывает на объект Superb или на объект любого класса, унаследованного от Superb. 
В частности, оно также равно true, если pg указывает на объект Magnificient. 
В примере #2 условие if равно true только для объекта Superb, а не для объектов, производных от Superb. 

7. Чем отличается операция static_cast от операции dynamic_cast? 
7. Операция dynamic_cast позволяет выполнять только восходящее приведение типов в иерархии класса, а операция static_cast — как восходящее, так и нисходящее приведение. 
Операция static_cast также позволяет выполнять преобразование перечислимых типов в целочисленные и наоборот, а также преобразование между различными числовыми типами. 
